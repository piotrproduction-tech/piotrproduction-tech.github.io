===== FILE: api.js =====

export async function getSubmissions() {
  return [
    { id: "1", title: "Film 1", status: "submitted", director: "Autor 1" },
    { id: "2", title: "Film 2", status: "selected", director: "Autor 2" }
  ];
}

export async function getSubmissionById(id) {
  return {
    id,
    title: "Mock Film " + id,
    director: "Mock Autor",
    status: "submitted",
    synopsis: "To jest przykładowy opis filmu.",
    duration: 90
  };
}

export async function createSubmission(payload) {
  console.log("createSubmission (mock)", payload);
  return { success: true, id: String(Date.now()) };
}



// API_SUBMISSIONS
export async function getFestivalSubmissions() {
  const res = await fetch("/api/festival/submissions");
  return res.json();
}

export async function createFestivalSubmission(payload) {
  const res = await fetch("/api/festival/submissions", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  return res.json();
}

export async function getSubmissionDetails(id) {
  const res = await fetch("/api/festival/submissions/" + id);
  return res.json();
}



// API_JURY
export async function getJuryMembers() {
  const res = await fetch("/api/festival/jury");
  return res.json();
}

export async function assignSubmissionToJury(submissionId, juryId) {
  const res = await fetch("/api/festival/jury/assign", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ submissionId, juryId })
  });
  return res.json();
}

export async function getJuryAssignments() {
  const res = await fetch("/api/festival/jury/assignments");
  return res.json();
}

export async function getJuryAssignmentsForCurrent() {
  const res = await fetch("/api/festival/jury/my-assignments");
  return res.json();
}

export async function submitJuryVote(submissionId, score, comment) {
  const res = await fetch("/api/festival/jury/vote", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ submissionId, score, comment })
  });
  return res.json();
}



// API_AWARDS
export async function getAwardCategories() {
  const res = await fetch("/api/festival/awards/categories");
  return res.json();
}

export async function createAwardCategory(name, description) {
  const res = await fetch("/api/festival/awards/categories", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, description })
  });
  return res.json();
}

export async function grantAward(categoryId, submissionId) {
  const res = await fetch("/api/festival/awards/grant", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ categoryId, submissionId })
  });
  return res.json();
}



// API_EVENTS
export async function getFestivalEvents() {
  const res = await fetch("/api/festival/events");
  return res.json();
}

export async function createFestivalEvent(name, startsAt, endsAt) {
  const res = await fetch("/api/festival/events", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, startsAt, endsAt })
  });
  return res.json();
}

export async function updateFestivalEvent(id, patch) {
  const res = await fetch("/api/festival/events/" + id, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(patch)
  });
  return res.json();
}



// API_SCHEDULE
export async function getFestivalSchedule() {
  const res = await fetch("/api/festival/schedule");
  return res.json();
}

export async function addToFestivalSchedule(eventId, slot) {
  const res = await fetch("/api/festival/schedule", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ eventId, slot })
  });
  return res.json();
}



// API_STATS
export async function getFestivalStats() {
  const res = await fetch("/api/festival/stats");
  return res.json();
}

export async function getFestivalStatsTimeline() {
  const res = await fetch("/api/festival/stats/timeline");
  return res.json();
}



// API_HEATMAP
export async function getFestivalHeatmap() {
  const res = await fetch("/api/festival/heatmap");
  return res.json();
}



// API_NARRATIVE
export async function getFestivalNarrative() {
  const res = await fetch("/api/festival/narrative");
  return res.json();
}



// API_AI
export async function getFestivalAIPredictions() {
  const res = await fetch("/api/festival/ai/predictions");
  return res.json();
}

===== END FILE: api.js =====

===== FILE: economy.bootstrap.js =====




// FE_FESTIVAL_ECONOMY_BOOTSTRAP
// Attach Festival Pavilion to CityEconomyEngine on FE side

import { registerCityEconomyBus } from "./core/economyBus";

export function bootstrapFestivalEconomy(cityEconomyBus) {
  registerCityEconomyBus(cityEconomyBus);
  console.log("[FESTIVAL] Economy connected to CityEconomyEngine");
}

===== END FILE: economy.bootstrap.js =====

===== FILE: governance.bootstrap.js =====




// FE_FESTIVAL_GOVERNANCE_BOOTSTRAP
// Attach Festival Pavilion to CityGovernanceEngine on FE side

import { registerCityGovernanceBus } from "./core/governanceBus";

export function bootstrapFestivalGovernance(cityGovernanceBus) {
  registerCityGovernanceBus(cityGovernanceBus);
  console.log("[FESTIVAL] Governance connected to CityGovernanceEngine");
}

===== END FILE: governance.bootstrap.js =====

===== FILE: identity.bootstrap.js =====




// FE_FESTIVAL_IDENTITY_BOOTSTRAP
// Attach Festival Pavilion to CityIdentityEngine on FE side

import { registerCityIdentityBus } from "./core/identityBus";

export function bootstrapFestivalIdentity(cityIdentityBus) {
  registerCityIdentityBus(cityIdentityBus);
  console.log("[FESTIVAL] Identity connected to CityIdentityEngine");
}

===== END FILE: identity.bootstrap.js =====

===== FILE: index.js =====

import { FilmSubmissionsWorkflowPanel } from "./PANELS/FilmSubmissionsWorkflowPanel";
import { JuryWorkflowPanel } from "./PANELS/JuryWorkflowPanel";
import { EventWorkflowPanel } from "./PANELS/EventWorkflowPanel";
import React from "react";
import SubmissionsList from "./panels/SubmissionsList.jsx";
import SubmissionDetails from "./panels/SubmissionDetails.jsx";
import SubmissionsForm from "./FORMS/SubmissionsForm.jsx";

export const FestivalPavilionModule = {
  config: {
    id: "FE-01",
    name: "Festival Pavilion",
    baseRoute: "/festival"
  },

  router: (route) => {
    if (route === "/festival") return <SubmissionsList />;
    if (route === "/festival/submit") return <SubmissionsForm />;

    if (route.startsWith("/festival/submission/")) {
      const id = route.split("/").pop();
      return <SubmissionDetails submissionId={id} />;
    }

    return <div>Nie znaleziono strony FESTIWALU: {route}</div>;
  }
};

===== END FILE: index.js =====

===== FILE: module.config.json =====

{
  "id": "FE-01",
  "name": "Festival Pavilion",
  "baseRoute": "/festival",
  "description": "Moduł Festiwalowy CITYOF-GATE"
}

===== END FILE: module.config.json =====

===== FILE: narrative.bootstrap.js =====




// FE_FESTIVAL_NARRATIVE_BOOTSTRAP
// Attach Festival Pavilion to CityNarrativeEngine on FE side

import { registerCityNarrativeBus } from "./core/narrativeBus";

export function bootstrapFestivalNarrative(cityNarrativeBus) {
  registerCityNarrativeBus(cityNarrativeBus);
  console.log("[FESTIVAL] Narrative feed connected to CityNarrativeEngine");
}

===== END FILE: narrative.bootstrap.js =====

===== FILE: pulsemood.bootstrap.js =====




// FE_FESTIVAL_PULSE_MOOD_BOOTSTRAP
// Attach Festival Pavilion to CityPulseEngine & CityMoodEngine on FE side

import { registerCityPulseBus, registerCityMoodBus } from "./core/pulseMoodBus";

export function bootstrapFestivalPulseMood(cityPulseBus, cityMoodBus) {
  registerCityPulseBus(cityPulseBus);
  registerCityMoodBus(cityMoodBus);
  console.log("[FESTIVAL] Pulse & Mood connected to CityPulseEngine + CityMoodEngine");
}

===== END FILE: pulsemood.bootstrap.js =====

===== FILE: reputation.bootstrap.js =====




// FE_FESTIVAL_REPUTATION_BOOTSTRAP
// Attach Festival Pavilion to CityReputationEngine on FE side

import { registerCityReputationBus } from "./core/reputationBus";

export function bootstrapFestivalReputation(cityReputationBus) {
  registerCityReputationBus(cityReputationBus);
  console.log("[FESTIVAL] Reputation connected to CityReputationEngine");
}

===== END FILE: reputation.bootstrap.js =====

===== FILE: security.bootstrap.js =====




// FE_FESTIVAL_SECURITY_BOOTSTRAP
// Attach Festival Pavilion to CitySecurityEngine on FE side

import { registerCitySecurityBus } from "./core/securityBus";

export function bootstrapFestivalSecurity(citySecurityBus) {
  registerCitySecurityBus(citySecurityBus);
  console.log("[FESTIVAL] Security connected to CitySecurityEngine");
}

===== END FILE: security.bootstrap.js =====

===== FILE: simulation.bootstrap.js =====




// FE_FESTIVAL_SIMULATION_BOOTSTRAP
// Attach Festival Pavilion to CitySimulationEngine & CityEmergenceEngine on FE side

import { registerCitySimulationBus, registerCityEmergenceBus } from "./core/simulationBus";

export function bootstrapFestivalSimulation(citySimulationBus, cityEmergenceBus) {
  registerCitySimulationBus(citySimulationBus);
  registerCityEmergenceBus(cityEmergenceBus);
  console.log("[FESTIVAL] Simulation & Emergence connected to CitySimulationEngine + CityEmergenceEngine");
}

===== END FILE: simulation.bootstrap.js =====

===== FILE: access\accessEvaluator.js =====




// FE_FESTIVAL_ACCESS_EVALUATOR
// Evaluates final permissions for a user

import { FestivalAccessMatrix } from "./accessMatrix";

export function evaluateFestivalAccess(identity, governance, security) {
  const role = governance?.roles?.[0] || "viewer";
  const trust = security?.trustLevel || "medium";
  const certs = governance?.certifications || [];

  let base = { ...FestivalAccessMatrix.roles[role] };
  let trustMod = FestivalAccessMatrix.trust[trust] || {};
  let certMod = {};

  certs.forEach(c => {
    if (FestivalAccessMatrix.certifications[c]) {
      certMod = { ...certMod, ...FestivalAccessMatrix.certifications[c] };
    }
  });

  return {
    ...base,
    ...trustMod,
    ...certMod
  };
}

===== END FILE: access\accessEvaluator.js =====

===== FILE: access\accessMatrix.js =====




// FE_FESTIVAL_ACCESS_MATRIX
// Central access matrix for Festival Pavilion

export const FestivalAccessMatrix = {
  roles: {
    viewer: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: false,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    participant: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: false,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    creator: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: false,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    certifiedCreator: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: false,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    jury: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: true,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    admin: {
      canViewDashboard: true,
      canViewAwards: true,
      canViewSchedule: true,
      canVote: true,
      canAssignJury: true,
      canCreateAwards: true,
      canManageEvents: true
    }
  },

  // trust-level modifiers
  trust: {
    low: {
      canVote: false,
      canAssignJury: false,
      canCreateAwards: false,
      canManageEvents: false
    },
    medium: {},
    high: {}
  },

  // certification modifiers
  certifications: {
    "festival_badge": {
      canVote: true
    },
    "jury_certified": {
      canVote: true,
      canAssignJury: true
    },
    "creator_certified": {
      canCreateAwards: true
    }
  }
};

===== END FILE: access\accessMatrix.js =====

===== FILE: ADMIN\AdminAwardsPanel.js =====

export default function AdminAwardsPanel() {
  return <div>Admin Awards Panel</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_NARRATIVE_INTEGRATION
import { useFestivalNarrativeLive } from "../core/useFestivalNarrativeLive";

useFestivalNarrativeLive((story) => {
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_REPUTATION_INTEGRATION
import { useFestivalReputationLive } from "../core/useFestivalReputationLive";

useFestivalReputationLive((rep) => {
  if (typeof setReputation === "function") setReputation(rep);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ECONOMY_INTEGRATION
import { useFestivalEconomyLive } from "../core/useFestivalEconomyLive";

useFestivalEconomyLive((eco) => {
  if (typeof setEconomy === "function") setEconomy(eco);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SECURITY_INTEGRATION
import { useFestivalSecurityLive } from "../core/useFestivalSecurityLive";

useFestivalSecurityLive((sec) => {
  if (typeof setSecurity === "function") setSecurity(sec);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ACCESS_INTEGRATION
import { useFestivalAccess } from "../core/useFestivalAccess";

const access = useFestivalAccess(identity, governance, security);

// Example UI guards:
if (!access.canViewDashboard && typeof hidePanel === "function") hidePanel();
if (!access.canVote && typeof disableVoting === "function") disableVoting();
if (!access.canAssignJury && typeof disableAssign === "function") disableAssign();
if (!access.canCreateAwards && typeof disableAwardCreation === "function") disableAwardCreation();
if (!access.canManageEvents && typeof disableEventManagement === "function") disableEventManagement();



// FE_FESTIVAL_USERCARD_INTEGRATION
import { UserCard } from "../components/UserCard";
import { useUserCardData } from "../core/useUserCardData";

const usercard = useUserCardData(identity, governance, security);

// Example usage inside panel render:
// <UserCard {...usercard} />



// FE_FESTIVAL_HUD_INTEGRATION
import { FestivalHUD } from "../components/FestivalHUD";
import { useFestivalHUD } from "../core/useFestivalHUD";

const hud = useFestivalHUD(identity, governance, security);

// Example usage inside render:
// <FestivalHUD {...hud} />



// IMMERSIVE_AWARDS_UPGRADE
// Real award workflow, API integration, UI logic

import { getAwardCategories, createAwardCategory, grantAward, getFestivalSubmissions } from "../api";

export function useImmersiveAwards(setCategories, setSubmissions) {
  async function load() {
    try {
      const [cats, subs] = await Promise.all([
        getAwardCategories(),
        getFestivalSubmissions()
      ]);
      setCategories(cats || []);
      setSubmissions(subs || []);
    } catch (e) {
      console.warn("ImmersiveAwards load error", e);
    }
  }
  return load;
}

===== END FILE: ADMIN\AdminAwardsPanel.js =====

===== FILE: ADMIN\AdminDashboard.js =====

export default function AdminDashboard() {
  return <div>Festival Admin Dashboard</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_NARRATIVE_INTEGRATION
import { useFestivalNarrativeLive } from "../core/useFestivalNarrativeLive";

useFestivalNarrativeLive((story) => {
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_PULSE_MOOD_INTEGRATION
import { useFestivalPulseMoodLive } from "../core/useFestivalPulseMoodLive";

useFestivalPulseMoodLive(
  (bpm) => {
    if (typeof setPulse === "function") setPulse(bpm);
  },
  (mood) => {
    if (typeof setMood === "function") setMood(mood);
  }
);



// FE_FESTIVAL_REPUTATION_INTEGRATION
import { useFestivalReputationLive } from "../core/useFestivalReputationLive";

useFestivalReputationLive((rep) => {
  if (typeof setReputation === "function") setReputation(rep);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SIMULATION_INTEGRATION
import { useFestivalSimulationLive } from "../core/useFestivalSimulationLive";

useFestivalSimulationLive(
  (wave) => {
    if (typeof setWave === "function") setWave(wave);
    if (typeof load === "function") load(); // refresh panel
  },
  (pattern) => {
    if (typeof setPattern === "function") setPattern(pattern);
    if (typeof load === "function") load();
  }
);



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ECONOMY_INTEGRATION
import { useFestivalEconomyLive } from "../core/useFestivalEconomyLive";

useFestivalEconomyLive((eco) => {
  if (typeof setEconomy === "function") setEconomy(eco);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SECURITY_INTEGRATION
import { useFestivalSecurityLive } from "../core/useFestivalSecurityLive";

useFestivalSecurityLive((sec) => {
  if (typeof setSecurity === "function") setSecurity(sec);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ACCESS_INTEGRATION
import { useFestivalAccess } from "../core/useFestivalAccess";

const access = useFestivalAccess(identity, governance, security);

// Example UI guards:
if (!access.canViewDashboard && typeof hidePanel === "function") hidePanel();
if (!access.canVote && typeof disableVoting === "function") disableVoting();
if (!access.canAssignJury && typeof disableAssign === "function") disableAssign();
if (!access.canCreateAwards && typeof disableAwardCreation === "function") disableAwardCreation();
if (!access.canManageEvents && typeof disableEventManagement === "function") disableEventManagement();



// FE_FESTIVAL_USERCARD_INTEGRATION
import { UserCard } from "../components/UserCard";
import { useUserCardData } from "../core/useUserCardData";

const usercard = useUserCardData(identity, governance, security);

// Example usage inside panel render:
// <UserCard {...usercard} />



// FE_FESTIVAL_ADMIN_ACCESS_PANEL_INTEGRATION
import { AdminAccessPanel } from "../components/AdminAccessPanel";
import { useAdminAccessPanel } from "../core/useAdminAccessPanel";

const accessPanel = useAdminAccessPanel(identity, governance, security);

// Example usage inside render:
// <AdminAccessPanel {...accessPanel} onOverride={(a) => console.log("Override:", a)} />



// FE_FESTIVAL_HUD_INTEGRATION
import { FestivalHUD } from "../components/FestivalHUD";
import { useFestivalHUD } from "../core/useFestivalHUD";

const hud = useFestivalHUD(identity, governance, security);

// Example usage inside render:
// <FestivalHUD {...hud} />



// FE_FESTIVAL_DEBUG_CONSOLE_INTEGRATION
import { FestivalDebugConsole } from "../components/FestivalDebugConsole";
import { useFestivalDebugConsole } from "../core/useFestivalDebugConsole";

const debugConsole = useFestivalDebugConsole();

// Example usage inside render:
// <FestivalDebugConsole
//   logs={debugConsole.logs}
//   collapsed={debugConsole.collapsed}
//   onToggle={debugConsole.toggle}
// />



// FE_FESTIVAL_NOTIFICATIONS_INTEGRATION
import { FestivalNotifications } from "../components/FestivalNotifications";
import { useFestivalNotifications } from "../core/useFestivalNotifications";

const notifications = useFestivalNotifications();

// Example usage inside render:
// <FestivalNotifications notifications={notifications} />



// FE_FESTIVAL_OVERLAY_INTEGRATION
import { FestivalOverlay } from "../components/FestivalOverlay";
import { useFestivalOverlay } from "../core/useFestivalOverlay";

const overlay = useFestivalOverlay(identity, governance, security);

// Example usage inside render:
// <FestivalOverlay {...overlay} />



// FE_FESTIVAL_OVERLAY_CONTROLLER_DASHBOARD
import { FestivalOverlayController } from "../components/FestivalOverlayController";
import { useFestivalOverlayController } from "../core/useFestivalOverlayController";

const overlayController = useFestivalOverlayController();

// Example usage inside render:
// <FestivalOverlayController {...overlayController} />



// IMMERSIVE_DASHBOARD_UPGRADE
// LivePulse, MoodBadge, AI Predictions, LiveEventFeed, NarrativeHighlights, Charts, Heatmap

import FestivalCharts from "../ANALYTICS/FestivalCharts";
import FestivalHeatmap from "../ANALYTICS/FestivalHeatmap";
import FestivalAIPredictions from "../AI/FestivalAIPredictions";
import { getFestivalStats, getFestivalEvents, getFestivalNarrative, getFestivalAIPredictions } from "../api";

export function useImmersiveDashboard(setStats, setEvents, setStories, setAI, setPulse, setMood) {
  async function load() {
    try {
      const [s, ev, st, aiData] = await Promise.all([
        getFestivalStats(),
        getFestivalEvents(),
        getFestivalNarrative(),
        getFestivalAIPredictions()
      ]);
      setStats(s || {});
      setEvents(ev || []);
      setStories(st || []);
      setAI(aiData || { hotCategories: [], potentialWinners: [] });
      if (s?.pulseBpm) setPulse(s.pulseBpm);
      if (s?.mood) setMood(s.mood);
    } catch (e) {
      console.warn("ImmersiveDashboard load error", e);
    }
  }
  return load;
}

===== END FILE: ADMIN\AdminDashboard.js =====

===== FILE: ADMIN\AdminJuryPanel.js =====

export default function AdminJuryPanel() {
  return <div>Admin Jury Panel</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_NARRATIVE_INTEGRATION
import { useFestivalNarrativeLive } from "../core/useFestivalNarrativeLive";

useFestivalNarrativeLive((story) => {
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SECURITY_INTEGRATION
import { useFestivalSecurityLive } from "../core/useFestivalSecurityLive";

useFestivalSecurityLive((sec) => {
  if (typeof setSecurity === "function") setSecurity(sec);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ACCESS_INTEGRATION
import { useFestivalAccess } from "../core/useFestivalAccess";

const access = useFestivalAccess(identity, governance, security);

// Example UI guards:
if (!access.canViewDashboard && typeof hidePanel === "function") hidePanel();
if (!access.canVote && typeof disableVoting === "function") disableVoting();
if (!access.canAssignJury && typeof disableAssign === "function") disableAssign();
if (!access.canCreateAwards && typeof disableAwardCreation === "function") disableAwardCreation();
if (!access.canManageEvents && typeof disableEventManagement === "function") disableEventManagement();



// FE_FESTIVAL_USERCARD_INTEGRATION
import { UserCard } from "../components/UserCard";
import { useUserCardData } from "../core/useUserCardData";

const usercard = useUserCardData(identity, governance, security);

// Example usage inside panel render:
// <UserCard {...usercard} />



// IMMERSIVE_JURY_UPGRADE
// Jury assignment logic, API integration, live updates

import { getJuryMembers, getFestivalSubmissions, assignSubmissionToJury, getJuryAssignments } from "../api";

export function useImmersiveJury(setJury, setSubmissions, setAssignments) {
  async function load() {
    try {
      const [j, s, a] = await Promise.all([
        getJuryMembers(),
        getFestivalSubmissions(),
        getJuryAssignments()
      ]);
      setJury(j || []);
      setSubmissions(s || []);
      setAssignments(a || []);
    } catch (e) {
      console.warn("ImmersiveJury load error", e);
    }
  }
  return load;
}

===== END FILE: ADMIN\AdminJuryPanel.js =====

===== FILE: ADMIN\AdminSchedulePanel.js =====

export default function AdminSchedulePanel() {
  return <div>Admin Schedule Panel</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_NARRATIVE_INTEGRATION
import { useFestivalNarrativeLive } from "../core/useFestivalNarrativeLive";

useFestivalNarrativeLive((story) => {
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SIMULATION_INTEGRATION
import { useFestivalSimulationLive } from "../core/useFestivalSimulationLive";

useFestivalSimulationLive(
  (wave) => {
    if (typeof setWave === "function") setWave(wave);
    if (typeof load === "function") load(); // refresh panel
  },
  (pattern) => {
    if (typeof setPattern === "function") setPattern(pattern);
    if (typeof load === "function") load();
  }
);



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ACCESS_INTEGRATION
import { useFestivalAccess } from "../core/useFestivalAccess";

const access = useFestivalAccess(identity, governance, security);

// Example UI guards:
if (!access.canViewDashboard && typeof hidePanel === "function") hidePanel();
if (!access.canVote && typeof disableVoting === "function") disableVoting();
if (!access.canAssignJury && typeof disableAssign === "function") disableAssign();
if (!access.canCreateAwards && typeof disableAwardCreation === "function") disableAwardCreation();
if (!access.canManageEvents && typeof disableEventManagement === "function") disableEventManagement();



// FE_FESTIVAL_USERCARD_INTEGRATION
import { UserCard } from "../components/UserCard";
import { useUserCardData } from "../core/useUserCardData";

const usercard = useUserCardData(identity, governance, security);

// Example usage inside panel render:
// <UserCard {...usercard} />



// FE_FESTIVAL_HUD_INTEGRATION
import { FestivalHUD } from "../components/FestivalHUD";
import { useFestivalHUD } from "../core/useFestivalHUD";

const hud = useFestivalHUD(identity, governance, security);

// Example usage inside render:
// <FestivalHUD {...hud} />



// IMMERSIVE_SCHEDULE_UPGRADE
// Event creation, schedule management, API integration

import { getFestivalEvents, createFestivalEvent, updateFestivalEvent, getFestivalSchedule, addToFestivalSchedule } from "../api";

export function useImmersiveSchedule(setEvents, setSchedule) {
  async function load() {
    try {
      const [ev, sch] = await Promise.all([
        getFestivalEvents(),
        getFestivalSchedule()
      ]);
      setEvents(ev || []);
      setSchedule(sch || []);
    } catch (e) {
      console.warn("ImmersiveSchedule load error", e);
    }
  }
  return load;
}

===== END FILE: ADMIN\AdminSchedulePanel.js =====

===== FILE: AI\FestivalAIPredictions.js =====

import { useFestivalAI } from "./useFestivalAI";

export default function FestivalAIPredictions() {
  const predictions = useFestivalAI();

  return (
    <div>
      <h3>Festival AI Predictions</h3>
      <div>Hot categories: {predictions.hotCategories.join(", ") || "brak"}</div>
      <div>Potential winners: {predictions.potentialWinners.join(", ") || "brak"}</div>
    </div>
  );
}

===== END FILE: AI\FestivalAIPredictions.js =====

===== FILE: AI\useFestivalAI.js =====

import { useState, useEffect } from "react";

export function useFestivalAI() {
  const [predictions, setPredictions] = useState({ hotCategories: [], potentialWinners: [] });

  useEffect(() => {
    // TODO: integrate with City AI Engine
    setPredictions({
      hotCategories: [],
      potentialWinners: []
    });
  }, []);

  return predictions;
}

===== END FILE: AI\useFestivalAI.js =====

===== FILE: ANALYTICS\FestivalCharts.js =====

export default function FestivalCharts() {
  return <div>Festival Charts (TODO: wykresy aktywności)</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_PULSE_MOOD_INTEGRATION
import { useFestivalPulseMoodLive } from "../core/useFestivalPulseMoodLive";

useFestivalPulseMoodLive(
  (bpm) => {
    if (typeof setPulse === "function") setPulse(bpm);
  },
  (mood) => {
    if (typeof setMood === "function") setMood(mood);
  }
);



// FE_FESTIVAL_REPUTATION_INTEGRATION
import { useFestivalReputationLive } from "../core/useFestivalReputationLive";

useFestivalReputationLive((rep) => {
  if (typeof setReputation === "function") setReputation(rep);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SIMULATION_INTEGRATION
import { useFestivalSimulationLive } from "../core/useFestivalSimulationLive";

useFestivalSimulationLive(
  (wave) => {
    if (typeof setWave === "function") setWave(wave);
    if (typeof load === "function") load(); // refresh panel
  },
  (pattern) => {
    if (typeof setPattern === "function") setPattern(pattern);
    if (typeof load === "function") load();
  }
);



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ECONOMY_INTEGRATION
import { useFestivalEconomyLive } from "../core/useFestivalEconomyLive";

useFestivalEconomyLive((eco) => {
  if (typeof setEconomy === "function") setEconomy(eco);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SECURITY_INTEGRATION
import { useFestivalSecurityLive } from "../core/useFestivalSecurityLive";

useFestivalSecurityLive((sec) => {
  if (typeof setSecurity === "function") setSecurity(sec);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_HUD_INTEGRATION
import { FestivalHUD } from "../components/FestivalHUD";
import { useFestivalHUD } from "../core/useFestivalHUD";

const hud = useFestivalHUD(identity, governance, security);

// Example usage inside render:
// <FestivalHUD {...hud} />



// FE_FESTIVAL_DEBUG_CONSOLE_INTEGRATION
import { FestivalDebugConsole } from "../components/FestivalDebugConsole";
import { useFestivalDebugConsole } from "../core/useFestivalDebugConsole";

const debugConsole = useFestivalDebugConsole();

// Example usage inside render:
// <FestivalDebugConsole
//   logs={debugConsole.logs}
//   collapsed={debugConsole.collapsed}
//   onToggle={debugConsole.toggle}
// />



// FE_FESTIVAL_NOTIFICATIONS_INTEGRATION
import { FestivalNotifications } from "../components/FestivalNotifications";
import { useFestivalNotifications } from "../core/useFestivalNotifications";

const notifications = useFestivalNotifications();

// Example usage inside render:
// <FestivalNotifications notifications={notifications} />



// IMMERSIVE_CHARTS_UPGRADE
// Timeline charts, animated bars, API integration

import { getFestivalStatsTimeline } from "../api";

export function useImmersiveCharts(setTimeline) {
  async function load() {
    try {
      const t = await getFestivalStatsTimeline();
      setTimeline(t || []);
    } catch (e) {
      console.warn("ImmersiveCharts error", e);
    }
  }
  return load;
}

===== END FILE: ANALYTICS\FestivalCharts.js =====

===== FILE: ANALYTICS\FestivalHeatmap.js =====

export default function FestivalHeatmap() {
  return <div>Festival Heatmap (TODO: integracja z City Heatmap)</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_PULSE_MOOD_INTEGRATION
import { useFestivalPulseMoodLive } from "../core/useFestivalPulseMoodLive";

useFestivalPulseMoodLive(
  (bpm) => {
    if (typeof setPulse === "function") setPulse(bpm);
  },
  (mood) => {
    if (typeof setMood === "function") setMood(mood);
  }
);



// FE_FESTIVAL_SIMULATION_INTEGRATION
import { useFestivalSimulationLive } from "../core/useFestivalSimulationLive";

useFestivalSimulationLive(
  (wave) => {
    if (typeof setWave === "function") setWave(wave);
    if (typeof load === "function") load(); // refresh panel
  },
  (pattern) => {
    if (typeof setPattern === "function") setPattern(pattern);
    if (typeof load === "function") load();
  }
);



// FE_FESTIVAL_ECONOMY_INTEGRATION
import { useFestivalEconomyLive } from "../core/useFestivalEconomyLive";

useFestivalEconomyLive((eco) => {
  if (typeof setEconomy === "function") setEconomy(eco);
  if (typeof load === "function") load(); // refresh panel
});



// IMMERSIVE_HEATMAP_UPGRADE
// Heatmap integration with backend, animated cells

import { getFestivalHeatmap } from "../api";

export function useImmersiveHeatmap(setHeat) {
  async function load() {
    try {
      const h = await getFestivalHeatmap();
      setHeat(h || { submissions: [], jury: [], awards: [] });
    } catch (e) {
      console.warn("ImmersiveHeatmap error", e);
    }
  }
  return load;
}

===== END FILE: ANALYTICS\FestivalHeatmap.js =====

===== FILE: ANALYTICS\FestivalStats.js =====

export default function FestivalStats({ stats }) {
  return (
    <div>
      <h3>Festival Stats</h3>
      <div>Zgłoszenia: {stats?.submissions ?? 0}</div>
      <div>Jurorzy: {stats?.jury ?? 0}</div>
      <div>Kategorie nagród: {stats?.awardCategories ?? 0}</div>
    </div>
  );
}

===== END FILE: ANALYTICS\FestivalStats.js =====

===== FILE: components\AdminAccessPanel.css =====




/* FE_FESTIVAL_ADMIN_ACCESS_CSS */

.admin-access-panel {
  padding: 20px;
  border-radius: 12px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.access-section {
  margin-bottom: 20px;
}

.override-grid {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.override-row {
  display: flex;
  gap: 12px;
  align-items: center;
}

.override-key {
  width: 200px;
  font-weight: bold;
}

===== END FILE: components\AdminAccessPanel.css =====

===== FILE: components\AdminAccessPanel.js =====




// FE_FESTIVAL_ADMIN_ACCESS_PANEL
// Visualizes Access Matrix + allows admin override

import React, { useState } from "react";
import { FestivalAccessMatrix } from "../access/accessMatrix";
import { evaluateFestivalAccess } from "../access/accessEvaluator";

export function AdminAccessPanel({ identity, governance, security, onOverride }) {
  const [override, setOverride] = useState(null);

  const current = evaluateFestivalAccess(identity, governance, security);

  function applyOverride(key, value) {
    const updated = { ...current, [key]: value };
    setOverride(updated);
    if (typeof onOverride === "function") onOverride(updated);
  }

  const finalAccess = override || current;

  return (
    <div className="admin-access-panel">
      <h2>Access Matrix — Festival Pavilion</h2>

      <div className="access-section">
        <h3>Current Access</h3>
        <pre>{JSON.stringify(current, null, 2)}</pre>
      </div>

      <div className="access-section">
        <h3>Override (Admin Only)</h3>
        <div className="override-grid">
          {Object.keys(current).map((key) => (
            <div key={key} className="override-row">
              <span className="override-key">{key}</span>
              <button onClick={() => applyOverride(key, true)}>Allow</button>
              <button onClick={() => applyOverride(key, false)}>Deny</button>
            </div>
          ))}
        </div>
      </div>

      <div className="access-section">
        <h3>Final Access</h3>
        <pre>{JSON.stringify(finalAccess, null, 2)}</pre>
      </div>
    </div>
  );
}

===== END FILE: components\AdminAccessPanel.js =====

===== FILE: components\FestivalDebugConsole.css =====




/* FE_FESTIVAL_DEBUG_CONSOLE_CSS */

.festival-debug-console {
  position: fixed;
  bottom: 8px;
  right: 8px;
  width: 420px;
  max-height: 40vh;
  background: rgba(0,0,0,0.85);
  color: #fff;
  font-size: 11px;
  border-radius: 8px;
  overflow: hidden;
  z-index: 9999;
}

.festival-debug-console.collapsed {
  max-height: 24px;
}

.debug-header {
  padding: 4px 8px;
  background: rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  cursor: pointer;
}

.debug-body {
  padding: 4px 8px;
  max-height: 36vh;
  overflow-y: auto;
}

.debug-line {
  display: flex;
  gap: 4px;
  margin-bottom: 2px;
}

.debug-time {
  opacity: 0.6;
}

.debug-source {
  font-weight: bold;
}

.debug-message {
  flex: 1;
}

.debug-narrative { color: #ffd27f; }
.debug-pulse { color: #ff7f7f; }
.debug-mood { color: #7fd4ff; }
.debug-simulation { color: #b27fff; }
.debug-reputation { color: #7fff9f; }
.debug-governance { color: #ffb27f; }
.debug-security { color: #ff7fb2; }
.debug-identity { color: #7fffff; }
.debug-economy { color: #fff27f; }

===== END FILE: components\FestivalDebugConsole.css =====

===== FILE: components\FestivalDebugConsole.js =====




// FE_FESTIVAL_DEBUG_CONSOLE_COMPONENT
// Live debug console for all Festival Pavilion engines

import React from "react";
import "./FestivalDebugConsole.css";

export function FestivalDebugConsole({ logs, collapsed, onToggle }) {
  return (
    <div className={"festival-debug-console" + (collapsed ? " collapsed" : "")}>
      <div className="debug-header" onClick={onToggle}>
        <span>Festival Debug Console</span>
        <span>{collapsed ? "▲" : "▼"}</span>
      </div>

      {!collapsed && (
        <div className="debug-body">
          {logs.map((log, idx) => (
            <div key={idx} className={"debug-line debug-" + log.source}>
              <span className="debug-time">{log.time}</span>
              <span className="debug-source">[{log.source}]</span>
              <span className="debug-message">{log.message}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

===== END FILE: components\FestivalDebugConsole.js =====

===== FILE: components\FestivalHUD.css =====




/* FE_FESTIVAL_HUD_CSS */

.festival-hud {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-radius: 12px;
  margin-bottom: 16px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.hud-left {
  display: flex;
  gap: 12px;
  align-items: center;
}

.hud-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
}

.hud-user {
  display: flex;
  flex-direction: column;
}

.hud-name {
  font-size: 16px;
  font-weight: bold;
}

.hud-badge {
  display: inline-block;
  padding: 2px 6px;
  margin-right: 4px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  font-size: 12px;
}

.hud-center {
  display: flex;
  gap: 16px;
}

.hud-item {
  opacity: 0.9;
}

.hud-right {
  max-width: 200px;
  overflow: hidden;
}

.mood-Calm { background: rgba(100,150,255,0.1); }
.mood-Energetic { background: rgba(255,120,80,0.1); }
.mood-Creative { background: rgba(255,200,80,0.1); }
.mood-Tense { background: rgba(255,80,80,0.1); }

===== END FILE: components\FestivalHUD.css =====

===== FILE: components\FestivalHUD.js =====




// FE_FESTIVAL_HUD_COMPONENT
// Live HUD for Festival Pavilion — pulse, mood, wave, reputation, identity, access

import React from "react";
import "./FestivalHUD.css";

export function FestivalHUD({ pulse, mood, wave, reputation, identity, access }) {
  const avatar = identity?.avatar || "/default-avatar.png";
  const name = identity?.profile?.name || "Unknown";
  const badges = identity?.badges || [];
  const level = reputation?.level || 0;
  const trust = reputation?.trustLevel || "medium";

  return (
    <div className={"festival-hud mood-" + mood}>
      <div className="hud-left">
        <img className="hud-avatar" src={avatar} alt="avatar" />
        <div className="hud-user">
          <div className="hud-name">{name}</div>
          <div className="hud-badges">
            {badges.map((b) => (
              <span key={b} className="hud-badge">{b}</span>
            ))}
          </div>
        </div>
      </div>

      <div className="hud-center">
        <div className="hud-item">Pulse: {pulse} BPM</div>
        <div className="hud-item">Mood: {mood}</div>
        <div className="hud-item">Wave: {wave?.label || "—"}</div>
        <div className="hud-item">Reputation: {reputation?.points || 0}</div>
        <div className="hud-item">Level: {level}</div>
      </div>

      <div className="hud-right">
        <div className="hud-access">
          <pre>{JSON.stringify(access, null, 2)}</pre>
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalHUD.js =====

===== FILE: components\FestivalNotifications.css =====




/* FE_FESTIVAL_NOTIFICATIONS_CSS */
.festival-notifications {
  position: fixed;
  top: 12px;
  right: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 9998;
}

.notif {
  padding: 10px 14px;
  border-radius: 8px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  max-width: 280px;
  animation: fadeIn 0.3s ease-out;
}

.notif-title {
  font-weight: bold;
  margin-bottom: 4px;
}

.notif-narrative { border-left: 4px solid #ffd27f; }
.notif-reputation { border-left: 4px solid #7fff9f; }
.notif-governance { border-left: 4px solid #ffb27f; }
.notif-security { border-left: 4px solid #ff7fb2; }
.notif-identity { border-left: 4px solid #7fffff; }
.notif-economy { border-left: 4px solid #fff27f; }
.notif-simulation { border-left: 4px solid #b27fff; }
.notif-pulse { border-left: 4px solid #ff7f7f; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-6px); }
  to { opacity: 1; transform: translateY(0); }
}

===== END FILE: components\FestivalNotifications.css =====

===== FILE: components\FestivalNotifications.js =====




// FE_FESTIVAL_NOTIFICATIONS_COMPONENT
import React from "react";
import "./FestivalNotifications.css";

export function FestivalNotifications({ notifications }) {
  return (
    <div className="festival-notifications">
      {notifications.map((n, i) => (
        <div key={i} className={"notif notif-" + n.type}>
          <div className="notif-title">{n.title}</div>
          <div className="notif-body">{n.message}</div>
        </div>
      ))}
    </div>
  );
}

===== END FILE: components\FestivalNotifications.js =====

===== FILE: components\FestivalOverlay.css =====




/* FE_FESTIVAL_OVERLAY_CSS */

.festival-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9997;
}

.mode-transparent { opacity: 0.4; }
.mode-semi { opacity: 0.75; }
.mode-full { opacity: 1; }

===== END FILE: components\FestivalOverlay.css =====

===== FILE: components\FestivalOverlay.js =====




// FE_FESTIVAL_OVERLAY_COMPONENT
import React from "react";
import "./FestivalOverlay.css";

import { FestivalHUD } from "./FestivalHUD";
import { FestivalDebugConsole } from "./FestivalDebugConsole";
import { FestivalNotifications } from "./FestivalNotifications";

export function FestivalOverlay({ hud, debug, notifications, mode }) {
  return (
    <div className={"festival-overlay mode-" + mode}>
      <FestivalHUD {...hud} />
      <FestivalNotifications notifications={notifications} />
      <FestivalDebugConsole
        logs={debug.logs}
        collapsed={debug.collapsed}
        onToggle={debug.toggle}
      />
    </div>
  );
}



// FE_FESTIVAL_OVERLAY_CONTROLLER_INTEGRATION
import { FestivalOverlayController } from "./FestivalOverlayController";
import { useFestivalOverlayController } from "../core/useFestivalOverlayController";

const controller = useFestivalOverlayController();

// Example usage inside render:
// <FestivalOverlayController {...controller} />
//
// And pass controller.mode + controller.toggles to FestivalOverlay



// FE_FESTIVAL_OVERLAY_QUICKSWITCH_OVERLAY
// (Optional) QuickSwitch can also be initialized here if needed



// FE_FESTIVAL_OVERLAY_REMOTECONTROL_OVERLAY
// (Optional) RemoteControl can also be initialized here if needed

===== END FILE: components\FestivalOverlay.js =====

===== FILE: components\FestivalOverlayAIDirectorControlPanel.css =====




/* FE_FESTIVAL_AI_DIRECTOR_CONTROL_PANEL_CSS */

.director-control {
  width: 260px;
  background: rgba(0,0,0,0.75);
  padding: 12px;
  border-radius: 10px;
  color: #fff;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  border: 1px solid rgba(255,255,255,0.1);
}

.director-control-header {
  font-size: 14px;
  font-weight: bold;
  text-align: center;
}

.director-control-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.director-control-label {
  opacity: 0.7;
  font-size: 11px;
}

.director-control-select,
.director-control-textarea {
  background: rgba(255,255,255,0.1);
  border: none;
  padding: 6px;
  border-radius: 6px;
  color: #fff;
}

.director-control-textarea {
  height: 60px;
  resize: none;
}

.director-control-btn {
  padding: 6px;
  background: rgba(0,255,150,0.2);
  border: none;
  border-radius: 6px;
  color: #fff;
  cursor: pointer;
}

.director-control-btn.danger {
  background: rgba(255,0,0,0.3);
}

===== END FILE: components\FestivalOverlayAIDirectorControlPanel.css =====

===== FILE: components\FestivalOverlayAIDirectorControlPanel.js =====




// FE_FESTIVAL_AI_DIRECTOR_CONTROL_PANEL_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayAIDirectorControlPanel.css";

import { FestivalAIDirectorProfilesUltra } from "../core/director/festivalAIDirectorProfilesUltra";
import { setDirectorMode } from "../core/director/festivalAIDirectorSystem";
import { setDirectorMood } from "../core/director/festivalAIDirectorMoodEngine";
import { rememberDirectorEvent } from "../core/director/festivalAIDirectorMemory";

export function FestivalOverlayAIDirectorControlPanel({ director, onForceDecision }) {
  const [forcedDecision, setForcedDecision] = useState("");

  const profiles = Object.keys(FestivalAIDirectorProfilesUltra);

  return (
    <div className="director-control">
      <div className="director-control-header">
        <span className="director-control-title">AI Director Control</span>
      </div>

      <div className="director-control-section">
        <div className="director-control-label">Active Profile</div>
        <select
          className="director-control-select"
          value={director?.profile}
          onChange={(e) => {
            rememberDirectorEvent({ type: "MANUAL_PROFILE_SET", profile: e.target.value });
            onForceDecision({ manualProfile: e.target.value });
          }}
        >
          {profiles.map((p) => (
            <option key={p} value={p}>{p}</option>
          ))}
        </select>
      </div>

      <div className="director-control-section">
        <div className="director-control-label">Mode</div>
        <select
          className="director-control-select"
          value={director?.mode}
          onChange={(e) => {
            setDirectorMode(e.target.value);
            rememberDirectorEvent({ type: "MANUAL_MODE_SET", mode: e.target.value });
          }}
        >
          <option value="FILMIC">FILMIC</option>
          <option value="SYSTEMIC">SYSTEMIC</option>
          <option value="HYBRID">HYBRID</option>
        </select>
      </div>

      <div className="director-control-section">
        <div className="director-control-label">Mood</div>
        <select
          className="director-control-select"
          value={director?.mood}
          onChange={(e) => {
            setDirectorMood(e.target.value);
            rememberDirectorEvent({ type: "MANUAL_MOOD_SET", mood: e.target.value });
          }}
        >
          <option value="Calm">Calm</option>
          <option value="Energetic">Energetic</option>
          <option value="Creative">Creative</option>
          <option value="Tense">Tense</option>
          <option value="Focused">Focused</option>
          <option value="Chaotic">Chaotic</option>
        </select>
      </div>

      <div className="director-control-section">
        <div className="director-control-label">Force Decision</div>
        <textarea
          className="director-control-textarea"
          value={forcedDecision}
          onChange={(e) => setForcedDecision(e.target.value)}
          placeholder="{ action: 'trigger_scene', scene: 'spotlight' }"
        />

        <button
          className="director-control-btn"
          onClick={() => {
            try {
              const parsed = JSON.parse(forcedDecision);
              onForceDecision({ manualDecision: parsed });
              rememberDirectorEvent({ type: "MANUAL_DECISION", decision: parsed });
            } catch (err) {
              alert("Invalid JSON");
            }
          }}
        >
          Apply
        </button>
      </div>

      <div className="director-control-section">
        <button
          className="director-control-btn danger"
          onClick={() => {
            rememberDirectorEvent({ type: "RESET_MEMORY" });
            onForceDecision({ resetMemory: true });
          }}
        >
          Reset Memory
        </button>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorControlPanel.js =====

===== FILE: components\FestivalOverlayAIDirectorHUD.css =====




/* FE_FESTIVAL_AI_DIRECTOR_HUD_CSS */

.director-hud {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 220px;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(6px);
  padding: 10px;
  border-radius: 10px;
  color: #fff;
  font-size: 11px;
  z-index: 999999;
  border: 1px solid rgba(255,255,255,0.15);
  box-shadow: 0 0 12px rgba(0,255,255,0.2);
}

.director-hud-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
}

.director-hud-label {
  opacity: 0.7;
}

.director-hud-value {
  font-weight: 600;
}

.director-hud-row.decision {
  margin-top: 10px;
}

.decision-text {
  font-size: 10px;
  opacity: 0.9;
  max-width: 120px;
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

===== END FILE: components\FestivalOverlayAIDirectorHUD.css =====

===== FILE: components\FestivalOverlayAIDirectorHUD.js =====




// FE_FESTIVAL_AI_DIRECTOR_HUD_COMPONENT
import React from "react";
import "./FestivalOverlayAIDirectorHUD.css";

export function FestivalOverlayAIDirectorHUD({ director }) {
  if (!director) return null;

  const { profile, mode, mood, decision } = director;

  return (
    <div className="director-hud">
      <div className="director-hud-row">
        <span className="director-hud-label">Profile</span>
        <span className="director-hud-value">{profile}</span>
      </div>

      <div className="director-hud-row">
        <span className="director-hud-label">Mode</span>
        <span className="director-hud-value">{mode}</span>
      </div>

      <div className="director-hud-row">
        <span className="director-hud-label">Mood</span>
        <span className="director-hud-value">{mood}</span>
      </div>

      <div className="director-hud-row decision">
        <span className="director-hud-label">Decision</span>
        <span className="director-hud-value decision-text">
          {decision ? JSON.stringify(decision) : "—"}
        </span>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorHUD.js =====

===== FILE: components\FestivalOverlayAIDirectorHUDUltra.css =====




/* FE_FESTIVAL_AI_DIRECTOR_HUD_ULTRA_CSS */

.director-hud-ultra {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 260px;
  background: rgba(0,0,20,0.75);
  backdrop-filter: blur(8px);
  padding: 14px;
  border-radius: 14px;
  color: #fff;
  font-size: 12px;
  z-index: 999999;
  border: 2px solid rgba(0,255,255,0.4);
  box-shadow: 0 0 25px rgba(0,255,255,0.25);
  animation: hudGlow 3s infinite alternate;
}

@keyframes hudGlow {
  from { box-shadow: 0 0 10px rgba(0,255,255,0.2); }
  to { box-shadow: 0 0 25px rgba(0,255,255,0.5); }
}

.hud-ultra-header {
  text-align: center;
  margin-bottom: 10px;
}

.hud-ultra-title {
  font-size: 13px;
  font-weight: bold;
  letter-spacing: 1px;
  opacity: 0.9;
}

.hud-ultra-radar {
  width: 100%;
  height: 100px;
  margin-bottom: 10px;
}

.hud-ultra-radar-ring {
  fill: none;
  stroke: rgba(0,255,255,0.2);
  stroke-width: 2;
}

.hud-ultra-radar-line {
  stroke: rgba(0,255,255,0.5);
  stroke-width: 2;
  animation: radarSweep 4s linear infinite;
  transform-origin: 50% 50%;
}

@keyframes radarSweep {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.hud-ultra-section {
  display: flex;
  justify-content: space-between;
  margin-bottom: 6px;
}

.hud-ultra-label {
  opacity: 0.7;
}

.hud-ultra-value {
  font-weight: 600;
}

.hud-ultra-waveform {
  height: 30px;
  margin: 10px 0;
  overflow: hidden;
}

.hud-ultra-wave {
  width: 200%;
  height: 100%;
  background: repeating-linear-gradient(
    to right,
    rgba(0,255,255,0.4) 0px,
    rgba(0,255,255,0.4) 2px,
    transparent 2px,
    transparent 4px
  );
  animation: waveMove 2s linear infinite;
}

@keyframes waveMove {
  from { transform: translateX(0); }
  to { transform: translateX(-50%); }
}

.decision-text {
  font-size: 10px;
  opacity: 0.9;
  max-width: 140px;
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

===== END FILE: components\FestivalOverlayAIDirectorHUDUltra.css =====

===== FILE: components\FestivalOverlayAIDirectorHUDUltra.js =====




// FE_FESTIVAL_AI_DIRECTOR_HUD_ULTRA_COMPONENT
import React from "react";
import "./FestivalOverlayAIDirectorHUDUltra.css";

export function FestivalOverlayAIDirectorHUDUltra({ director }) {
  if (!director) return null;

  const { profile, mode, mood, decision } = director;

  const moodColor = {
    Calm: "#4ffff0",
    Energetic: "#ff4f9a",
    Creative: "#ffdd4f",
    Tense: "#ff4f4f",
    Focused: "#4fff8a",
    Chaotic: "#ff7bff"
  }[mood] || "#ffffff";

  return (
    <div className="director-hud-ultra" style={{ borderColor: moodColor }}>
      <div className="hud-ultra-header">
        <span className="hud-ultra-title">DIRECTOR VISION HUD</span>
      </div>

      <div className="hud-ultra-radar">
        <svg viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="45" className="hud-ultra-radar-ring" />
          <circle cx="50" cy="50" r="30" className="hud-ultra-radar-ring" />
          <circle cx="50" cy="50" r="15" className="hud-ultra-radar-ring" />
          <line x1="50" y1="50" x2="95" y2="50" className="hud-ultra-radar-line" />
        </svg>
      </div>

      <div className="hud-ultra-section">
        <span className="hud-ultra-label">Profile</span>
        <span className="hud-ultra-value" style={{ color: moodColor }}>{profile}</span>
      </div>

      <div className="hud-ultra-section">
        <span className="hud-ultra-label">Mode</span>
        <span className="hud-ultra-value">{mode}</span>
      </div>

      <div className="hud-ultra-section">
        <span className="hud-ultra-label">Mood</span>
        <span className="hud-ultra-value" style={{ color: moodColor }}>{mood}</span>
      </div>

      <div className="hud-ultra-waveform">
        <div className="hud-ultra-wave" />
      </div>

      <div className="hud-ultra-section decision">
        <span className="hud-ultra-label">Decision</span>
        <span className="hud-ultra-value decision-text">
          {decision ? JSON.stringify(decision) : "—"}
        </span>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorHUDUltra.js =====

===== FILE: components\FestivalOverlayAIDirectorMonitor.css =====




/* FE_FESTIVAL_AI_DIRECTOR_MONITOR_CSS */

.director-monitor {
  width: 260px;
  background: rgba(0,0,0,0.75);
  padding: 12px;
  border-radius: 10px;
  color: #fff;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  border: 1px solid rgba(255,255,255,0.1);
}

.director-monitor-header {
  font-size: 14px;
  font-weight: bold;
  text-align: center;
}

.director-monitor-section {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.director-monitor-label {
  opacity: 0.7;
  font-size: 11px;
}

.director-monitor-value {
  background: rgba(255,255,255,0.1);
  padding: 6px;
  border-radius: 6px;
  font-size: 12px;
}

.director-monitor-history {
  max-height: 140px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.director-monitor-history-item {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  opacity: 0.8;
}

.decision-box {
  font-size: 10px;
  white-space: pre-wrap;
}

===== END FILE: components\FestivalOverlayAIDirectorMonitor.css =====

===== FILE: components\FestivalOverlayAIDirectorMonitor.js =====




// FE_FESTIVAL_AI_DIRECTOR_MONITOR_COMPONENT
import React from "react";
import "./FestivalOverlayAIDirectorMonitor.css";

export function FestivalOverlayAIDirectorMonitor({ director }) {
  if (!director) return null;

  const { profile, mode, mood, decision, history } = director;

  return (
    <div className="director-monitor">
      <div className="director-monitor-header">
        <span className="director-monitor-title">AI Director Monitor</span>
      </div>

      <div className="director-monitor-section">
        <div className="director-monitor-label">Profile</div>
        <div className="director-monitor-value">{profile}</div>
      </div>

      <div className="director-monitor-section">
        <div className="director-monitor-label">Mode</div>
        <div className="director-monitor-value">{mode}</div>
      </div>

      <div className="director-monitor-section">
        <div className="director-monitor-label">Mood</div>
        <div className="director-monitor-value">{mood}</div>
      </div>

      <div className="director-monitor-section">
        <div className="director-monitor-label">Last Decision</div>
        <div className="director-monitor-value decision-box">
          {JSON.stringify(decision, null, 2)}
        </div>
      </div>

      <div className="director-monitor-section">
        <div className="director-monitor-label">History (20)</div>
        <div className="director-monitor-history">
          {history.map((h, i) => (
            <div key={i} className="director-monitor-history-item">
              <span>{new Date(h.timestamp).toLocaleTimeString()}</span>
              <span>{h.profile}</span>
              <span>{h.mood}</span>
              <span>{h.type}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorMonitor.js =====

===== FILE: components\FestivalOverlayAIDirectorVisionModeSwitcher.css =====




/* FE_FESTIVAL_AI_DIRECTOR_VISION_MODE_SWITCHER_CSS */

.vision-switcher {
  display: flex;
  gap: 6px;
  background: rgba(0,0,0,0.6);
  padding: 6px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.1);
}

.vision-switcher button {
  background: rgba(255,255,255,0.1);
  border: none;
  padding: 6px 10px;
  border-radius: 6px;
  color: #fff;
  cursor: pointer;
  font-size: 11px;
}

.vision-switcher button.active {
  background: rgba(0,255,255,0.3);
  font-weight: bold;
}

===== END FILE: components\FestivalOverlayAIDirectorVisionModeSwitcher.css =====

===== FILE: components\FestivalOverlayAIDirectorVisionModeSwitcher.js =====




// FE_FESTIVAL_AI_DIRECTOR_VISION_MODE_SWITCHER_COMPONENT
import React from "react";
import "./FestivalOverlayAIDirectorVisionModeSwitcher.css";

export function FestivalOverlayAIDirectorVisionModeSwitcher({ mode, onChange }) {
  return (
    <div className="vision-switcher">
      <button
        className={mode === "OFF" ? "active" : ""}
        onClick={() => onChange("OFF")}
      >
        OFF
      </button>

      <button
        className={mode === "HUD" ? "active" : ""}
        onClick={() => onChange("HUD")}
      >
        HUD
      </button>

      <button
        className={mode === "HUD_ULTRA" ? "active" : ""}
        onClick={() => onChange("HUD_ULTRA")}
      >
        HUD Ultra
      </button>

      <button
        className={mode === "VISION" ? "active" : ""}
        onClick={() => onChange("VISION")}
      >
        Vision
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorVisionModeSwitcher.js =====

===== FILE: components\FestivalOverlayAIDirectorVisionOverlay.css =====




/* FE_FESTIVAL_AI_DIRECTOR_VISION_OVERLAY_CSS */

.director-vision-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 999998;
}

.vision-grid {
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(rgba(0,255,255,0.15) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0,255,255,0.15) 1px, transparent 1px);
  background-size: 40px 40px;
  border: 2px solid rgba(0,255,255,0.3);
  opacity: 0.4;
}

.vision-scan {
  position: absolute;
  top: -100%;
  left: 0;
  right: 0;
  height: 200%;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    rgba(0,255,255,0.15) 50%,
    transparent 100%
  );
  animation: scanMove 6s linear infinite;
}

@keyframes scanMove {
  from { transform: translateY(0); }
  to { transform: translateY(100%); }
}

.vision-corners .corner {
  position: absolute;
  width: 40px;
  height: 40px;
  border: 3px solid;
  opacity: 0.8;
}

.corner.tl { top: 10px; left: 10px; border-right: none; border-bottom: none; }
.corner.tr { top: 10px; right: 10px; border-left: none; border-bottom: none; }
.corner.bl { bottom: 10px; left: 10px; border-right: none; border-top: none; }
.corner.br { bottom: 10px; right: 10px; border-left: none; border-top: none; }

.vision-center-pulse {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 120px;
  height: 120px;
  transform: translate(-50%, -50%);
  border: 2px solid;
  border-radius: 50%;
  opacity: 0.6;
  animation: pulse 2.5s ease-in-out infinite;
}

@keyframes pulse {
  0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.4; }
  50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.4; }
}

===== END FILE: components\FestivalOverlayAIDirectorVisionOverlay.css =====

===== FILE: components\FestivalOverlayAIDirectorVisionOverlay.js =====




// FE_FESTIVAL_AI_DIRECTOR_VISION_OVERLAY_COMPONENT
import React from "react";
import "./FestivalOverlayAIDirectorVisionOverlay.css";

export function FestivalOverlayAIDirectorVisionOverlay({ director }) {
  if (!director) return null;

  const { mood } = director;

  const moodColor = {
    Calm: "#4ffff0",
    Energetic: "#ff4f9a",
    Creative: "#ffdd4f",
    Tense: "#ff4f4f",
    Focused: "#4fff8a",
    Chaotic: "#ff7bff"
  }[mood] || "#00ffff";

  return (
    <div className="director-vision-overlay">
      <div className="vision-grid" style={{ borderColor: moodColor }} />

      <div className="vision-scan" />

      <div className="vision-corners">
        <div className="corner tl" style={{ borderColor: moodColor }} />
        <div className="corner tr" style={{ borderColor: moodColor }} />
        <div className="corner bl" style={{ borderColor: moodColor }} />
        <div className="corner br" style={{ borderColor: moodColor }} />
      </div>

      <div className="vision-center-pulse" style={{ borderColor: moodColor }} />
    </div>
  );
}

===== END FILE: components\FestivalOverlayAIDirectorVisionOverlay.js =====

===== FILE: components\FestivalOverlayController.css =====




/* FE_FESTIVAL_OVERLAY_CONTROLLER_CSS */

.overlay-controller {
  position: fixed;
  bottom: 12px;
  left: 12px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  font-size: 13px;
}

.controller-section {
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.overlay-controller select {
  padding: 4px;
  border-radius: 4px;
}

===== END FILE: components\FestivalOverlayController.css =====

===== FILE: components\FestivalOverlayController.js =====




// FE_FESTIVAL_OVERLAY_CONTROLLER_COMPONENT
import React from "react";
import "./FestivalOverlayController.css";

export function FestivalOverlayController({ mode, setMode, toggles, setToggles }) {
  return (
    <div className="overlay-controller">
      <h3>Overlay Controller</h3>

      <div className="controller-section">
        <label>Overlay Mode:</label>
        <select value={mode} onChange={(e) => setMode(e.target.value)}>
          <option value="off">Off</option>
          <option value="transparent">Transparent</option>
          <option value="semi">Semi</option>
          <option value="full">Full</option>
        </select>
      </div>

      <div className="controller-section">
        <label>
          <input
            type="checkbox"
            checked={toggles.hud}
            onChange={() => setToggles({ ...toggles, hud: !toggles.hud })}
          />
          Show HUD
        </label>

        <label>
          <input
            type="checkbox"
            checked={toggles.notifications}
            onChange={() =>
              setToggles({ ...toggles, notifications: !toggles.notifications })
            }
          />
          Show Notifications
        </label>

        <label>
          <input
            type="checkbox"
            checked={toggles.debug}
            onChange={() => setToggles({ ...toggles, debug: !toggles.debug })}
          />
          Show Debug Console
        </label>
      </div>
    </div>
  );
}



// FE_FESTIVAL_OVERLAY_PRESET_MANAGER_INTEGRATION
import { FestivalOverlayPresetManager } from "./FestivalOverlayPresetManager";
import { useFestivalOverlayPresetManager } from "../core/useFestivalOverlayPresetManager";

const presetManager = useFestivalOverlayPresetManager({ mode, setMode, toggles, setToggles });

// Example usage inside render:
// <FestivalOverlayPresetManager presetManager={presetManager} />



// FE_FESTIVAL_OVERLAY_PRESET_SYNC_INTEGRATION
import { useFestivalOverlayPresetSync } from "../core/useFestivalOverlayPresetSync";

useFestivalOverlayPresetSync(presetManager, { mode, setMode, toggles, setToggles }, identity);



// FE_FESTIVAL_OVERLAY_QUICKSWITCH_INTEGRATION
import { useFestivalOverlayQuickSwitch } from "../core/useFestivalOverlayQuickSwitch";

useFestivalOverlayQuickSwitch(presetManager);



// FE_FESTIVAL_OVERLAY_REMOTECONTROL_INTEGRATION
import { useFestivalOverlayRemoteControl } from "../core/useFestivalOverlayRemoteControl";

useFestivalOverlayRemoteControl(presetManager, { mode, setMode, toggles, setToggles });



// FE_FESTIVAL_OVERLAY_MACRORECORDER_INTEGRATION
import { FestivalOverlayMacroRecorder } from "./FestivalOverlayMacroRecorder";
import { useFestivalOverlayMacroRecorder } from "../core/useFestivalOverlayMacroRecorder";

const macro = useFestivalOverlayMacroRecorder(presetManager, { mode, setMode, toggles, setToggles });

// Example usage inside render:
// <FestivalOverlayMacroRecorder macro={macro} />



// FE_FESTIVAL_OVERLAY_SCENARIOENGINE_INTEGRATION
import { FestivalOverlayScenarioEngine } from "./FestivalOverlayScenarioEngine";
import { useFestivalOverlayScenarioEngine } from "../core/useFestivalOverlayScenarioEngine";

const scenario = useFestivalOverlayScenarioEngine(presetManager, { mode, setMode, toggles, setToggles });

// Example usage inside render:
// <FestivalOverlayScenarioEngine scenario={scenario} />



// FE_FESTIVAL_OVERLAY_SCENARIOCOMPOSER_INTEGRATION
import { FestivalOverlayScenarioComposer } from "./FestivalOverlayScenarioComposer";
import { useFestivalOverlayScenarioComposer } from "../core/useFestivalOverlayScenarioComposer";

const composer = useFestivalOverlayScenarioComposer();

// Example usage inside render:
// <FestivalOverlayScenarioComposer composer={composer} scenarioEngine={scenario} />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_CONTROLLER_INTEGRATION
import { FestivalOverlayScenarioAIController } from "./FestivalOverlayScenarioAIController";

// Example usage inside render:
// <FestivalOverlayScenarioAIController runAIScenario={runAIScenario} />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_PROFILE_CONTROLLER_INTEGRATION
import { FestivalOverlayScenarioAIProfileController } from "./FestivalOverlayScenarioAIProfileController";

// Example usage inside render:
// <FestivalOverlayScenarioAIProfileController
//    runScenarioSteps={runScenarioSteps}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_ORCHESTRATOR_CONTROLLER_INTEGRATION
import { FestivalOverlayScenarioAIOrchestratorController } from "./FestivalOverlayScenarioAIOrchestratorController";

// Example usage inside render:
// <FestivalOverlayScenarioAIOrchestratorController
//    orchestrator={orchestrator}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_AUTOTUNER_CONTROLLER_INTEGRATION
import { FestivalOverlayScenarioAIAutoTunerController } from "./FestivalOverlayScenarioAIAutoTunerController";

// Example usage inside render:
// <FestivalOverlayScenarioAIAutoTunerController
//    autoTuner={autoTuner}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERORCHESTRATOR_CONTROLLER_INTEGRATION
import { FestivalOverlayScenarioAIHyperOrchestratorController } from "./FestivalOverlayScenarioAIHyperOrchestratorController";

// Example usage inside render:
// <FestivalOverlayScenarioAIHyperOrchestratorController
//    hyper={hyper}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuite } from "./FestivalOverlayScenarioAIHyperSuite";

// Example usage inside render:
// <FestivalOverlayScenarioAIHyperSuite
//    runAIScenario={runAIScenario}
//    runScenarioSteps={runScenarioSteps}
//    orchestrator={orchestrator}
//    autoTuner={autoTuner}
//    hyper={hyper}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuiteDock } from "./FestivalOverlayScenarioAIHyperSuiteDock";

// Example usage inside render:
// <FestivalOverlayScenarioAIHyperSuiteDock
//    runAIScenario={runAIScenario}
//    runScenarioSteps={runScenarioSteps}
//    orchestrator={orchestrator}
//    autoTuner={autoTuner}
//    hyper={hyper}
//    getCurrentState={() => ({ pulse, mood, wave, reputation, identity, security, narrative })}
// />

===== END FILE: components\FestivalOverlayController.js =====

===== FILE: components\FestivalOverlayMacroRecorder.css =====




/* FE_FESTIVAL_OVERLAY_MACRORECORDER_CSS */

.overlay-macrorecorder {
  position: fixed;
  bottom: 12px;
  left: 240px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 240px;
  font-size: 13px;
}

.macro-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.overlay-macrorecorder button {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  border: none;
  cursor: pointer;
}

.overlay-macrorecorder input {
  padding: 6px;
  border-radius: 6px;
  border: none;
}

===== END FILE: components\FestivalOverlayMacroRecorder.css =====

===== FILE: components\FestivalOverlayMacroRecorder.js =====




// FE_FESTIVAL_OVERLAY_MACRORECORDER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayMacroRecorder.css";

export function FestivalOverlayMacroRecorder({ macro }) {
  const [macroName, setMacroName] = useState("");

  return (
    <div className="overlay-macrorecorder">
      <h3>Overlay Macro Recorder</h3>

      <div className="macro-section">
        <input
          type="text"
          placeholder="Macro name"
          value={macroName}
          onChange={(e) => setMacroName(e.target.value)}
        />

        {!macro.recording && (
          <button onClick={() => macro.startRecording(macroName)}>
            Start Recording
          </button>
        )}

        {macro.recording && (
          <button onClick={macro.stopRecording}>
            Stop Recording
          </button>
        )}
      </div>

      <div className="macro-section">
        <h4>Saved Macros</h4>
        {Object.keys(macro.macros).map((m) => (
          <button key={m} onClick={() => macro.playMacro(m)}>
            ▶ {m}
          </button>
        ))}
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayMacroRecorder.js =====

===== FILE: components\FestivalOverlayPresetManager.css =====




/* FE_FESTIVAL_OVERLAY_PRESET_MANAGER_CSS */

.overlay-preset-manager {
  position: fixed;
  bottom: 12px;
  right: 12px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  font-size: 13px;
  width: 220px;
}

.preset-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.overlay-preset-manager button {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  border: none;
  cursor: pointer;
}

.overlay-preset-manager input {
  padding: 6px;
  border-radius: 6px;
  border: none;
  margin-bottom: 6px;
}

.empty {
  opacity: 0.6;
  font-size: 12px;
}

===== END FILE: components\FestivalOverlayPresetManager.css =====

===== FILE: components\FestivalOverlayPresetManager.js =====




// FE_FESTIVAL_OVERLAY_PRESET_MANAGER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayPresetManager.css";
import { FestivalOverlayPresets } from "../core/overlayPresets";

export function FestivalOverlayPresetManager({ presetManager }) {
  const [newPresetName, setNewPresetName] = useState("");

  return (
    <div className="overlay-preset-manager">
      <h3>Overlay Presets</h3>

      <div className="preset-section">
        <h4>Default Presets</h4>
        {Object.keys(FestivalOverlayPresets).map((p) => (
          <button key={p} onClick={() => presetManager.applyPreset(p)}>
            {p}
          </button>
        ))}
      </div>

      <div className="preset-section">
        <h4>Custom Presets</h4>
        {Object.keys(presetManager.customPresets).length === 0 && (
          <div className="empty">No custom presets yet</div>
        )}

        {Object.keys(presetManager.customPresets).map((p) => (
          <button key={p} onClick={() => presetManager.applyPreset(p)}>
            {p}
          </button>
        ))}
      </div>

      <div className="preset-section">
        <h4>Save Current as Preset</h4>
        <input
          type="text"
          placeholder="Preset name"
          value={newPresetName}
          onChange={(e) => setNewPresetName(e.target.value)}
        />
        <button
          onClick={() => {
            if (newPresetName.trim()) {
              presetManager.savePreset(newPresetName.trim());
              setNewPresetName("");
            }
          }}
        >
          Save
        </button>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayPresetManager.js =====

===== FILE: components\FestivalOverlayScenarioAIAutoTunerController.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_AUTOTUNER_CONTROLLER_CSS */

.overlay-ai-autotuner-controller {
  position: fixed;
  bottom: 12px;
  left: 2000px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 260px;
  font-size: 13px;
}

.autotuner-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.autotuner-btn {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  cursor: pointer;
}

.autotuner-btn.active {
  background: rgba(80,255,80,0.3);
}

.autotuner-metrics,
.autotuner-history {
  padding: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.autotuner-history-row {
  display: flex;
  justify-content: space-between;
  opacity: 0.8;
}

.autotuner-run-btn {
  margin-top: 12px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(255,120,80,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioAIAutoTunerController.css =====

===== FILE: components\FestivalOverlayScenarioAIAutoTunerController.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_AUTOTUNER_CONTROLLER_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioAIAutoTunerController.css";

export function FestivalOverlayScenarioAIAutoTunerController({ autoTuner, getCurrentState }) {
  const state = getCurrentState();
  const history = autoTuner.history.current || [];

  // Compute metrics for display
  const avgPulse = history.length
    ? (history.reduce((a, s) => a + s.pulse, 0) / history.length).toFixed(1)
    : "-";

  const avgWave = history.length
    ? (history.reduce((a, s) => a + s.wave.intensity, 0) / history.length).toFixed(2)
    : "-";

  const dominantMood = history.length
    ? Object.entries(
        history.reduce((acc, s) => {
          acc[s.mood] = (acc[s.mood] || 0) + 1;
          return acc;
        }, {})
      ).sort((a, b) => b[1] - a[1])[0][0]
    : "-";

  return (
    <div className="overlay-ai-autotuner-controller">
      <h3>AI AutoTuner</h3>

      <div className="autotuner-section">
        <label>AutoTuner</label>
        <button
          className={autoTuner.enabled ? "autotuner-btn active" : "autotuner-btn"}
          onClick={() => autoTuner.setEnabled(!autoTuner.enabled)}
        >
          {autoTuner.enabled ? "ON" : "OFF"}
        </button>
      </div>

      <div className="autotuner-section">
        <label>Metrics</label>
        <div className="autotuner-metrics">
          <div><strong>Avg Pulse:</strong> {avgPulse}</div>
          <div><strong>Avg Wave:</strong> {avgWave}</div>
          <div><strong>Dominant Mood:</strong> {dominantMood}</div>
        </div>
      </div>

      <div className="autotuner-section">
        <label>History ({history.length})</label>
        <div className="autotuner-history">
          {history.slice(-10).map((s, i) => (
            <div key={i} className="autotuner-history-row">
              <span>P:{s.pulse}</span>
              <span>W:{s.wave.intensity}</span>
              <span>M:{s.mood}</span>
            </div>
          ))}
        </div>
      </div>

      <button className="autotuner-run-btn" onClick={() => autoTuner.setEnabled(true)}>
        ▶ Force Tune
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIAutoTunerController.js =====

===== FILE: components\FestivalOverlayScenarioAIController.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_CONTROLLER_CSS */

.overlay-ai-controller {
  position: fixed;
  bottom: 12px;
  left: 1040px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 300px;
  font-size: 13px;
}

.ai-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ai-run-btn {
  margin-top: 12px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(80,255,80,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioAIController.css =====

===== FILE: components\FestivalOverlayScenarioAIController.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_CONTROLLER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayScenarioAIController.css";

export function FestivalOverlayScenarioAIController({ runAIScenario }) {
  const [state, setState] = useState({
    pulse: 90,
    mood: "Calm",
    wave: { intensity: 0.3, trend: "stable" },
    reputation: { level: 1, points: 0 },
    identity: { role: "guest", badges: [] },
    security: { trustLevel: "medium" },
    narrative: { phase: "default", tag: "" }
  });

  function update(path, value) {
    const parts = path.split(".");
    setState((prev) => {
      const next = { ...prev };
      let ref = next;
      for (let i = 0; i < parts.length - 1; i++) {
        ref[parts[i]] = { ...ref[parts[i]] };
        ref = ref[parts[i]];
      }
      ref[parts[parts.length - 1]] = value;
      return next;
    });
  }

  return (
    <div className="overlay-ai-controller">
      <h3>AI Scenario Controller</h3>

      <div className="ai-section">
        <label>Pulse</label>
        <input
          type="number"
          value={state.pulse}
          onChange={(e) => update("pulse", Number(e.target.value))}
        />

        <label>Mood</label>
        <select
          value={state.mood}
          onChange={(e) => update("mood", e.target.value)}
        >
          <option>Calm</option>
          <option>Energetic</option>
          <option>Creative</option>
          <option>Tense</option>
        </select>

        <label>Wave Intensity</label>
        <input
          type="number"
          step="0.1"
          value={state.wave.intensity}
          onChange={(e) => update("wave.intensity", Number(e.target.value))}
        />

        <label>Wave Trend</label>
        <select
          value={state.wave.trend}
          onChange={(e) => update("wave.trend", e.target.value)}
        >
          <option>rising</option>
          <option>falling</option>
          <option>stable</option>
        </select>

        <label>Reputation Level</label>
        <input
          type="number"
          value={state.reputation.level}
          onChange={(e) => update("reputation.level", Number(e.target.value))}
        />

        <label>Reputation Points</label>
        <input
          type="number"
          value={state.reputation.points}
          onChange={(e) => update("reputation.points", Number(e.target.value))}
        />

        <label>Role</label>
        <select
          value={state.identity.role}
          onChange={(e) => update("identity.role", e.target.value)}
        >
          <option>guest</option>
          <option>creator</option>
          <option>jury</option>
          <option>admin</option>
        </select>

        <label>Security Trust</label>
        <select
          value={state.security.trustLevel}
          onChange={(e) => update("security.trustLevel", e.target.value)}
        >
          <option>low</option>
          <option>medium</option>
          <option>high</option>
        </select>

        <label>Narrative Phase</label>
        <select
          value={state.narrative.phase}
          onChange={(e) => update("narrative.phase", e.target.value)}
        >
          <option>default</option>
          <option>opening</option>
          <option>awards</option>
          <option>jury</option>
          <option>closing</option>
        </select>

        <label>Narrative Tag</label>
        <input
          type="text"
          value={state.narrative.tag}
          onChange={(e) => update("narrative.tag", e.target.value)}
        />
      </div>

      <button className="ai-run-btn" onClick={() => runAIScenario(state)}>
        ▶ Run AI Scenario
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIController.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperOrchestratorController.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERORCHESTRATOR_CONTROLLER_CSS */

.overlay-ai-hyperorchestrator-controller {
  position: fixed;
  bottom: 12px;
  left: 2320px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 260px;
  font-size: 13px;
}

.hyper-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.hyper-btn {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  cursor: pointer;
}

.hyper-btn.active {
  background: rgba(80,255,80,0.3);
}

.hyper-value {
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.hyper-metrics,
.hyper-history {
  padding: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.hyper-history-row {
  display: flex;
  justify-content: space-between;
  opacity: 0.8;
}

.hyper-run-btn {
  margin-top: 12px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(120,80,255,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperOrchestratorController.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperOrchestratorController.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERORCHESTRATOR_CONTROLLER_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioAIHyperOrchestratorController.css";

export function FestivalOverlayScenarioAIHyperOrchestratorController({ hyper, getCurrentState }) {
  const state = getCurrentState();
  const history = hyper.history.current || [];

  const avgPulse = history.length
    ? (history.reduce((a, s) => a + s.pulse, 0) / history.length).toFixed(1)
    : "-";

  const avgWave = history.length
    ? (history.reduce((a, s) => a + s.wave.intensity, 0) / history.length).toFixed(2)
    : "-";

  const dominantMood = history.length
    ? Object.entries(
        history.reduce((acc, s) => {
          acc[s.mood] = (acc[s.mood] || 0) + 1;
          return acc;
        }, {})
      ).sort((a, b) => b[1] - a[1])[0][0]
    : "-";

  return (
    <div className="overlay-ai-hyperorchestrator-controller">
      <h3>AI HyperOrchestrator</h3>

      <div className="hyper-section">
        <label>Hyper Mode</label>
        <button
          className={hyper.enabled ? "hyper-btn active" : "hyper-btn"}
          onClick={() => hyper.setEnabled(!hyper.enabled)}
        >
          {hyper.enabled ? "ON" : "OFF"}
        </button>
      </div>

      <div className="hyper-section">
        <label>Active Profile</label>
        <div className="hyper-value">{hyper.activeProfile}</div>
      </div>

      <div className="hyper-section">
        <label>Metrics</label>
        <div className="hyper-metrics">
          <div><strong>Avg Pulse:</strong> {avgPulse}</div>
          <div><strong>Avg Wave:</strong> {avgWave}</div>
          <div><strong>Dominant Mood:</strong> {dominantMood}</div>
        </div>
      </div>

      <div className="hyper-section">
        <label>History ({history.length})</label>
        <div className="hyper-history">
          {history.slice(-10).map((s, i) => (
            <div key={i} className="hyper-history-row">
              <span>P:{s.pulse}</span>
              <span>W:{s.wave.intensity}</span>
              <span>M:{s.mood}</span>
            </div>
          ))}
        </div>
      </div>

      <button className="hyper-run-btn" onClick={hyper.runOnce}>
        ▶ Run Hyper Scenario
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIHyperOrchestratorController.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuite.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_CSS */

.overlay-ai-hypersuite {
  position: fixed;
  bottom: 12px;
  left: 12px;
  display: flex;
  flex-direction: row;
  gap: 12px;
  z-index: 99999;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuite.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuite.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioAIHyperSuite.css";

import { FestivalOverlayScenarioAIController } from "./FestivalOverlayScenarioAIController";
import { FestivalOverlayScenarioAIProfileController } from "./FestivalOverlayScenarioAIProfileController";
import { FestivalOverlayScenarioAIOrchestratorController } from "./FestivalOverlayScenarioAIOrchestratorController";
import { FestivalOverlayScenarioAIAutoTunerController } from "./FestivalOverlayScenarioAIAutoTunerController";
import { FestivalOverlayScenarioAIHyperOrchestratorController } from "./FestivalOverlayScenarioAIHyperOrchestratorController";

export function FestivalOverlayScenarioAIHyperSuite({
  runAIScenario,
  runScenarioSteps,
  orchestrator,
  autoTuner,
  hyper,
  getCurrentState
}) {
  return (
    <div className="overlay-ai-hypersuite">
      <FestivalOverlayScenarioAIController
        runAIScenario={runAIScenario}
        getCurrentState={getCurrentState}
      />

      <FestivalOverlayScenarioAIProfileController
        runScenarioSteps={runScenarioSteps}
        getCurrentState={getCurrentState}
      />

      <FestivalOverlayScenarioAIOrchestratorController
        orchestrator={orchestrator}
        getCurrentState={getCurrentState}
      />

      <FestivalOverlayScenarioAIAutoTunerController
        autoTuner={autoTuner}
        getCurrentState={getCurrentState}
      />

      <FestivalOverlayScenarioAIHyperOrchestratorController
        hyper={hyper}
        getCurrentState={getCurrentState}
      />
    </div>
  );
}



// FE_FESTIVAL_AI_DIRECTOR_MONITOR_INTEGRATION
import { FestivalOverlayAIDirectorMonitor } from "./FestivalOverlayAIDirectorMonitor";

// Przykład użycia w HyperSuite:
// <FestivalOverlayAIDirectorMonitor director={director} />



// FE_FESTIVAL_AI_DIRECTOR_CONTROL_PANEL_INTEGRATION
import { FestivalOverlayAIDirectorControlPanel } from "./FestivalOverlayAIDirectorControlPanel";

// Przykład użycia:
// <FestivalOverlayAIDirectorControlPanel director={director} onForceDecision={handleForceDecision} />



// FE_FESTIVAL_AI_DIRECTOR_HUD_INTEGRATION
import { FestivalOverlayAIDirectorHUD } from "./FestivalOverlayAIDirectorHUD";

// Przykład użycia:
// <FestivalOverlayAIDirectorHUD director={director} />



// FE_FESTIVAL_AI_DIRECTOR_HUD_ULTRA_INTEGRATION
import { FestivalOverlayAIDirectorHUDUltra } from "./FestivalOverlayAIDirectorHUDUltra";

// Przykład:
// <FestivalOverlayAIDirectorHUDUltra director={director} />



// FE_FESTIVAL_AI_DIRECTOR_VISION_OVERLAY_INTEGRATION
import { FestivalOverlayAIDirectorVisionOverlay } from "./FestivalOverlayAIDirectorVisionOverlay";

// Przykład:
// <FestivalOverlayAIDirectorVisionOverlay director={director} />



// FE_FESTIVAL_AI_DIRECTOR_VISION_MODE_SWITCHER_INTEGRATION
import { FestivalOverlayAIDirectorVisionModeSwitcher } from "./FestivalOverlayAIDirectorVisionModeSwitcher";

// Przykład:
// <FestivalOverlayAIDirectorVisionModeSwitcher mode={visionMode} onChange={setVisionMode} />



// FE_FESTIVAL_AI_DIRECTOR_VISION_ORCHESTRATOR_UI
import { FestivalOverlayAIDirectorHUD } from "./FestivalOverlayAIDirectorHUD";
import { FestivalOverlayAIDirectorHUDUltra } from "./FestivalOverlayAIDirectorHUDUltra";
import { FestivalOverlayAIDirectorVisionOverlay } from "./FestivalOverlayAIDirectorVisionOverlay";
import { FestivalOverlayAIDirectorVisionModeSwitcher } from "./FestivalOverlayAIDirectorVisionModeSwitcher";
import { VisionModes } from "../core/festivalAIDirectorAutoVisionEngine";

// Przykładowy szkic integracji w komponencie HyperSuite:
//
// const [visionMode, setVisionMode] = useState("OFF");
// const [visionOverride, setVisionOverride] = useState(null);
//
// const handleVisionModeChange = (mode) => {
//   setVisionMode(mode);
//   setVisionOverride(mode === "AUTO" ? null : mode);
// };
//
// <FestivalOverlayAIDirectorVisionModeSwitcher
//   mode={visionMode}
//   onChange={handleVisionModeChange}
// />
//
// {visionMode === VisionModes.HUD && (
//   <FestivalOverlayAIDirectorHUD director={director} />
// )}
//
// {visionMode === VisionModes.HUD_ULTRA && (
//   <FestivalOverlayAIDirectorHUDUltra director={director} />
// )}
//
// {visionMode === VisionModes.VISION && (
//   <FestivalOverlayAIDirectorVisionOverlay director={director} />
// )}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuite.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDock.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_CSS */

.overlay-ai-hypersuite-dock {
  position: fixed;
  bottom: 12px;
  left: 12px;
  z-index: 100000;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.dock-toggle {
  padding: 8px 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
}

.dock-toggle.open {
  background: rgba(80,255,80,0.3);
}

.dock-panel {
  display: flex;
  flex-direction: row;
  gap: 12px;
  padding: 8px;
  background: rgba(0,0,0,0.65);
  border-radius: 8px;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDock.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDock.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayScenarioAIHyperSuiteDock.css";

import { FestivalOverlayScenarioAIHyperSuite } from "./FestivalOverlayScenarioAIHyperSuite";

export function FestivalOverlayScenarioAIHyperSuiteDock(props) {
  const [open, setOpen] = useState(false);

  return (
    <div className="overlay-ai-hypersuite-dock">
      <button
        className={open ? "dock-toggle open" : "dock-toggle"}
        onClick={() => setOpen(!open)}
      >
        {open ? "▼ AI Suite" : "▲ AI Suite"}
      </button>

      {open && (
        <div className="dock-panel">
          <FestivalOverlayScenarioAIHyperSuite {...props} />
        </div>
      )}
    </div>
  );
}



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_PRO_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro";

// Example usage next to dock:
// <FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro
//    getCurrentState={getCurrentState}
//    historyRef={hyper.history}
// />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuiteDockMiniMap } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMap";

// Example usage next to dock:
// <FestivalOverlayScenarioAIHyperSuiteDockMiniMap getCurrentState={getCurrentState} />



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_SWITCHER_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher";

// Example usage next to dock:
// <FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher
//    getCurrentState={getCurrentState}
//    historyRef={hyper.history}
// />



// FE_FESTIVAL_AI_DIRECTOR_MONITOR_DOCK_INTEGRATION
import { FestivalOverlayAIDirectorMonitor } from "./FestivalOverlayAIDirectorMonitor";

// Przykład użycia obok docka:
// <FestivalOverlayAIDirectorMonitor director={director} />



// FE_FESTIVAL_AI_DIRECTOR_CONTROL_PANEL_DOCK
import { FestivalOverlayAIDirectorControlPanel } from "./FestivalOverlayAIDirectorControlPanel";



// FE_FESTIVAL_AI_DIRECTOR_HUD_DOCK
import { FestivalOverlayAIDirectorHUD } from "./FestivalOverlayAIDirectorHUD";



// FE_FESTIVAL_AI_DIRECTOR_HUD_ULTRA_DOCK
import { FestivalOverlayAIDirectorHUDUltra } from "./FestivalOverlayAIDirectorHUDUltra";



// FE_FESTIVAL_AI_DIRECTOR_VISION_OVERLAY_DOCK
import { FestivalOverlayAIDirectorVisionOverlay } from "./FestivalOverlayAIDirectorVisionOverlay";



// FE_FESTIVAL_AI_DIRECTOR_VISION_MODE_SWITCHER_DOCK
import { FestivalOverlayAIDirectorVisionModeSwitcher } from "./FestivalOverlayAIDirectorVisionModeSwitcher";

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDock.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMap.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_CSS */

.mini-map-basic {
  position: fixed;
  bottom: 12px;
  left: 2500px;
  width: 140px;
  padding: 10px;
  background: rgba(0,0,0,0.75);
  border-radius: 8px;
  color: #fff;
  font-size: 12px;
  z-index: 100000;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.mini-map-basic-section {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.mini-map-basic-label {
  opacity: 0.7;
  font-size: 11px;
}

.mini-map-basic-pulse {
  font-size: 18px;
  font-weight: bold;
  text-align: center;
  animation: miniMapBasicPulse infinite ease-in-out;
}

@keyframes miniMapBasicPulse {
  0% { transform: scale(1); color: #fff; }
  50% { transform: scale(1.2); color: #ff4f4f; }
  100% { transform: scale(1); color: #fff; }
}

.mini-map-basic-wave-bar {
  width: 20px;
  height: 60px;
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
  overflow: hidden;
  margin: 0 auto;
}

.mini-map-basic-wave-fill {
  width: 100%;
  background: #4fff8a;
  transition: height 0.3s ease;
}

.mini-map-basic-mood {
  padding: 4px 6px;
  border-radius: 4px;
  text-align: center;
  font-size: 11px;
  font-weight: bold;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMap.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMap.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioAIHyperSuiteDockMiniMap.css";

export function FestivalOverlayScenarioAIHyperSuiteDockMiniMap({ getCurrentState }) {
  const state = getCurrentState();

  const pulse = state.pulse;
  const wave = state.wave.intensity;
  const mood = state.mood;

  const moodColor = {
    Calm: "#4fa3ff",
    Energetic: "#ff4f4f",
    Creative: "#ffb84f",
    Tense: "#9b4fff"
  }[mood] || "#ffffff";

  return (
    <div className="mini-map-basic">
      <div className="mini-map-basic-section">
        <div className="mini-map-basic-label">Pulse</div>
        <div
          className="mini-map-basic-pulse"
          style={{ animationDuration: `${2000 / pulse}ms` }}
        >
          {pulse}
        </div>
      </div>

      <div className="mini-map-basic-section">
        <div className="mini-map-basic-label">Wave</div>
        <div className="mini-map-basic-wave-bar">
          <div
            className="mini-map-basic-wave-fill"
            style={{ height: `${wave * 100}%` }}
          />
        </div>
      </div>

      <div className="mini-map-basic-section">
        <div className="mini-map-basic-label">Mood</div>
        <div
          className="mini-map-basic-mood"
          style={{ backgroundColor: moodColor }}
        >
          {mood}
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMap.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_PRO_CSS */

.mini-map-pro {
  position: fixed;
  bottom: 12px;
  left: 2600px;
  width: 220px;
  padding: 10px;
  background: radial-gradient(circle at top left, rgba(80,80,120,0.9), rgba(0,0,0,0.9));
  border-radius: 10px;
  color: #fff;
  font-size: 11px;
  z-index: 100000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  box-shadow: 0 0 18px rgba(0,0,0,0.8);
  border: 1px solid rgba(255,255,255,0.08);
}

.mini-map-pro-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  opacity: 0.9;
}

.mini-map-pro-title {
  font-weight: 600;
}

.mini-map-pro-tag {
  padding: 2px 6px;
  border-radius: 999px;
  background: rgba(255,255,255,0.08);
  font-size: 9px;
}

.mini-map-pro-row {
  display: flex;
  flex-direction: row;
  gap: 8px;
}

.mini-map-pro-block {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.mini-map-pro-label {
  opacity: 0.7;
  font-size: 10px;
}

.mini-map-pro-pulse {
  display: flex;
  align-items: baseline;
  gap: 4px;
  justify-content: center;
  animation: miniMapProPulse 1.2s infinite ease-in-out;
}

.mini-map-pro-pulse-value {
  font-size: 18px;
  font-weight: 700;
}

.mini-map-pro-pulse-unit {
  font-size: 9px;
  opacity: 0.8;
}

@keyframes miniMapProPulse {
  0% { transform: scale(1); color: #fff; }
  50% { transform: scale(1.08); color: #ff8080; }
  100% { transform: scale(1); color: #fff; }
}

.mini-map-pro-chart {
  width: 100%;
  height: 40px;
  background: rgba(0,0,0,0.4);
  border-radius: 6px;
  overflow: hidden;
}

.mini-map-pro-chart svg {
  width: 100%;
  height: 100%;
}

.mini-map-pro-wave {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.mini-map-pro-wave-bar {
  width: 14px;
  height: 40px;
  background: rgba(255,255,255,0.08);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.mini-map-pro-wave-fill {
  width: 100%;
  background: linear-gradient(to top, #4fff8a, #4ffff0);
  position: absolute;
  bottom: 0;
  transition: height 0.25s ease-out;
}

.mini-map-pro-wave-value {
  font-size: 11px;
  opacity: 0.9;
}

.mood-block .mini-map-pro-mood {
  height: 40px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 11px;
  text-shadow: 0 0 6px rgba(0,0,0,0.8);
}

.meta-block .mini-map-pro-meta-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
  font-size: 10px;
}

.mini-map-pro-meta-label {
  opacity: 0.6;
  display: block;
}

.mini-map-pro-meta-value {
  font-weight: 600;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_PRO_COMPONENT
import React, { useMemo } from "react";
import "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro.css";

export function FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro({ getCurrentState, historyRef }) {
  const state = getCurrentState();
  const history = historyRef?.current || [];

  const pulse = state.pulse;
  const wave = state.wave.intensity;
  const mood = state.mood;

  const moodColor = {
    Calm: "linear-gradient(135deg, #4fa3ff, #4ffff0)",
    Energetic: "linear-gradient(135deg, #ff4f4f, #ffb84f)",
    Creative: "linear-gradient(135deg, #ffb84f, #ffe94f)",
    Tense: "linear-gradient(135deg, #9b4fff, #ff4fb8)"
  }[mood] || "linear-gradient(135deg, #ffffff, #aaaaaa)";

  const pulseHistory = useMemo(
    () => history.slice(-20).map((s) => s.pulse),
    [history]
  );

  const waveHistory = useMemo(
    () => history.slice(-20).map((s) => s.wave.intensity),
    [history]
  );

  const maxPulse = Math.max(1, ...pulseHistory, pulse);
  const pulsePoints = pulseHistory.map((p, i) => {
    const x = (i / Math.max(1, pulseHistory.length - 1)) * 100;
    const y = 100 - (p / maxPulse) * 100;
    return `${x},${y}`;
  });

  const wavePoints = waveHistory.map((w, i) => {
    const x = (i / Math.max(1, waveHistory.length - 1)) * 100;
    const y = 100 - w * 100;
    return `${x},${y}`;
  });

  return (
    <div className="mini-map-pro">
      <div className="mini-map-pro-header">
        <span className="mini-map-pro-title">CITY HUD</span>
        <span className="mini-map-pro-tag">CINEMATIC</span>
      </div>

      <div className="mini-map-pro-row">
        <div className="mini-map-pro-block">
          <div className="mini-map-pro-label">Pulse</div>
          <div className="mini-map-pro-pulse">
            <span className="mini-map-pro-pulse-value">{pulse}</span>
            <span className="mini-map-pro-pulse-unit">BPM</span>
          </div>
          <div className="mini-map-pro-chart">
            <svg viewBox="0 0 100 100" preserveAspectRatio="none">
              <polyline
                points={pulsePoints.join(" ")}
                fill="none"
                stroke="#ff4f4f"
                strokeWidth="2"
              />
            </svg>
          </div>
        </div>

        <div className="mini-map-pro-block">
          <div className="mini-map-pro-label">Wave</div>
          <div className="mini-map-pro-wave">
            <div className="mini-map-pro-wave-bar">
              <div
                className="mini-map-pro-wave-fill"
                style={{ height: `${wave * 100}%` }}
              />
            </div>
            <span className="mini-map-pro-wave-value">
              {(wave * 100).toFixed(0)}%
            </span>
          </div>
          <div className="mini-map-pro-chart">
            <svg viewBox="0 0 100 100" preserveAspectRatio="none">
              <polyline
                points={wavePoints.join(" ")}
                fill="none"
                stroke="#4fff8a"
                strokeWidth="2"
              />
            </svg>
          </div>
        </div>
      </div>

      <div className="mini-map-pro-row">
        <div className="mini-map-pro-block mood-block">
          <div className="mini-map-pro-label">Mood</div>
          <div
            className="mini-map-pro-mood"
            style={{ backgroundImage: moodColor }}
          >
            <span className="mini-map-pro-mood-text">{mood}</span>
          </div>
        </div>

        <div className="mini-map-pro-block meta-block">
          <div className="mini-map-pro-label">Meta</div>
          <div className="mini-map-pro-meta-grid">
            <div>
              <span className="mini-map-pro-meta-label">Role</span>
              <span className="mini-map-pro-meta-value">{state.identity.role}</span>
            </div>
            <div>
              <span className="mini-map-pro-meta-label">Trust</span>
              <span className="mini-map-pro-meta-value">
                {state.security.trustLevel}
              </span>
            </div>
            <div>
              <span className="mini-map-pro-meta-label">Phase</span>
              <span className="mini-map-pro-meta-value">
                {state.narrative.phase}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_SWITCHER_CSS */

.mini-map-switcher {
  position: fixed;
  bottom: 12px;
  left: 2450px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 100000;
}

.switcher-btn {
  padding: 6px 10px;
  background: rgba(0,0,0,0.7);
  color: #fff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 11px;
}

.switcher-btn.active {
  background: rgba(80,255,80,0.3);
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_SWITCHER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher.css";

import { FestivalOverlayScenarioAIHyperSuiteDockMiniMap } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMap";
import { FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro";

export function FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher({
  getCurrentState,
  historyRef
}) {
  const [mode, setMode] = useState("basic");

  return (
    <div className="mini-map-switcher">
      <button
        className={mode === "basic" ? "switcher-btn active" : "switcher-btn"}
        onClick={() => setMode("basic")}
      >
        Basic
      </button>

      <button
        className={mode === "pro" ? "switcher-btn active" : "switcher-btn"}
        onClick={() => setMode("pro")}
      >
        Pro
      </button>

      {mode === "basic" && (
        <FestivalOverlayScenarioAIHyperSuiteDockMiniMap
          getCurrentState={getCurrentState}
        />
      )}

      {mode === "pro" && (
        <FestivalOverlayScenarioAIHyperSuiteDockMiniMapPro
          getCurrentState={getCurrentState}
          historyRef={historyRef}
        />
      )}
    </div>
  );
}



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_ULTRA_INTEGRATION
import { FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra } from "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra";

// Example usage:
// Add a third button "Ultra" and render MiniMapUltra when selected.

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapSwitcher.js =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_ULTRA_CSS */

.mini-map-ultra {
  position: fixed;
  bottom: 12px;
  left: 2750px;
  width: 260px;
  padding: 12px;
  background: rgba(0,0,20,0.85);
  border-radius: 12px;
  color: #fff;
  font-size: 11px;
  z-index: 100000;
  display: flex;
  flex-direction: column;
  gap: 12px;
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 0 20px rgba(0,255,255,0.2);
}

.ultra-header {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  opacity: 0.9;
}

.ultra-title {
  font-weight: 600;
}

.ultra-tag {
  padding: 2px 6px;
  background: rgba(0,255,255,0.15);
  border-radius: 999px;
}

.ultra-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.ultra-card {
  background: rgba(255,255,255,0.05);
  padding: 8px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ultra-label {
  font-size: 10px;
  opacity: 0.7;
}

.ultra-radar {
  width: 100%;
  height: 80px;
}

.ultra-radar-ring {
  fill: none;
  stroke: rgba(0,255,255,0.2);
  stroke-width: 2;
}

.ultra-radar-line {
  stroke: #4ffff0;
  stroke-width: 2;
}

.ultra-radar-dot {
  fill: #4ffff0;
}

.ultra-radar-phase {
  text-align: center;
  font-size: 10px;
  opacity: 0.8;
}

.ultra-rep-ring {
  position: relative;
  width: 100%;
  height: 80px;
}

.ultra-rep-bg {
  fill: none;
  stroke: rgba(255,255,255,0.1);
  stroke-width: 6;
}

.ultra-rep-fill {
  fill: none;
  stroke: #4fff8a;
  stroke-width: 6;
  stroke-linecap: round;
  transform: rotate(-90deg);
  transform-origin: 50% 50%;
  transition: stroke-dasharray 0.3s ease;
}

.ultra-rep-text {
  position: absolute;
  top: 22px;
  left: 0;
  width: 100%;
  text-align: center;
  font-size: 10px;
  font-weight: 600;
}

.ultra-trust {
  padding: 6px;
  border-radius: 6px;
  text-align: center;
  font-weight: 600;
  font-size: 11px;
}

.ultra-waves {
  width: 100%;
  height: 60px;
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra.css =====

===== FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERSUITE_DOCK_MINIMAP_ULTRA_COMPONENT
import React, { useMemo } from "react";
import "./FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra.css";

export function FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra({ getCurrentState, historyRef }) {
  const state = getCurrentState();
  const history = historyRef?.current || [];

  const pulse = state.pulse;
  const wave = state.wave.intensity;
  const mood = state.mood;
  const reputation = state.reputation;
  const trust = state.security.trustLevel;
  const narrative = state.narrative;

  const trustColor = {
    low: "#ff4f4f",
    medium: "#ffb84f",
    high: "#4fff8a"
  }[trust] || "#ffffff";

  const repPercent = Math.min(100, (reputation.points % 100));

  const radarAngle = {
    default: 0,
    opening: 45,
    awards: 135,
    jury: 225,
    closing: 315
  }[narrative.phase] || 0;

  const radarX = 50 + 40 * Math.cos((radarAngle * Math.PI) / 180);
  const radarY = 50 + 40 * Math.sin((radarAngle * Math.PI) / 180);

  const waveEnergy = useMemo(() => {
    return history.slice(-20).map((s, i) => ({
      x: i * 5,
      y: 30 + Math.sin(i * 0.6 + s.pulse / 20) * 10 + s.wave.intensity * 20
    }));
  }, [history]);

  return (
    <div className="mini-map-ultra">
      <div className="ultra-header">
        <span className="ultra-title">CITY ULTRA HUD</span>
        <span className="ultra-tag">DIRECTOR VISION</span>
      </div>

      <div className="ultra-grid">
        <div className="ultra-card">
          <div className="ultra-label">Narrative Radar</div>
          <svg viewBox="0 0 100 100" className="ultra-radar">
            <circle cx="50" cy="50" r="40" className="ultra-radar-ring" />
            <line x1="50" y1="50" x2={radarX} y2={radarY} className="ultra-radar-line" />
            <circle cx={radarX} cy={radarY} r="3" className="ultra-radar-dot" />
          </svg>
          <div className="ultra-radar-phase">{narrative.phase}</div>
        </div>

        <div className="ultra-card">
          <div className="ultra-label">Reputation</div>
          <div className="ultra-rep-ring">
            <svg viewBox="0 0 100 100">
              <circle cx="50" cy="50" r="40" className="ultra-rep-bg" />
              <circle
                cx="50"
                cy="50"
                r="40"
                className="ultra-rep-fill"
                strokeDasharray={`${repPercent * 2.5} 1000`}
              />
            </svg>
            <div className="ultra-rep-text">
              L{reputation.level}<br />{reputation.points} pts
            </div>
          </div>
        </div>

        <div className="ultra-card">
          <div className="ultra-label">Trust</div>
          <div className="ultra-trust" style={{ backgroundColor: trustColor }}>
            {trust}
          </div>
        </div>

        <div className="ultra-card">
          <div className="ultra-label">Energy Waves</div>
          <svg viewBox="0 0 100 60" className="ultra-waves">
            <polyline
              fill="none"
              stroke="#4ffff0"
              strokeWidth="2"
              points={waveEnergy.map((p) => `${p.x},${p.y}`).join(" ")}
            />
          </svg>
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIHyperSuiteDockMiniMapUltra.js =====

===== FILE: components\FestivalOverlayScenarioAIOrchestratorController.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_ORCHESTRATOR_CONTROLLER_CSS */

.overlay-ai-orchestrator-controller {
  position: fixed;
  bottom: 12px;
  left: 1680px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 260px;
  font-size: 13px;
}

.orch-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.orch-btn {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  border: none;
  color: #fff;
  cursor: pointer;
}

.orch-btn.active {
  background: rgba(80,255,80,0.3);
}

.orch-value {
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.orch-state {
  padding: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.orch-run-btn {
  margin-top: 12px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(255,200,80,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioAIOrchestratorController.css =====

===== FILE: components\FestivalOverlayScenarioAIOrchestratorController.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_ORCHESTRATOR_CONTROLLER_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioAIOrchestratorController.css";

export function FestivalOverlayScenarioAIOrchestratorController({ orchestrator, getCurrentState }) {
  const state = getCurrentState();

  return (
    <div className="overlay-ai-orchestrator-controller">
      <h3>AI Orchestrator</h3>

      <div className="orch-section">
        <label>Auto Mode</label>
        <button
          className={orchestrator.autoMode ? "orch-btn active" : "orch-btn"}
          onClick={() => orchestrator.setAutoMode(!orchestrator.autoMode)}
        >
          {orchestrator.autoMode ? "ON" : "OFF"}
        </button>
      </div>

      <div className="orch-section">
        <label>Active Profile</label>
        <div className="orch-value">{orchestrator.activeProfile}</div>
      </div>

      <div className="orch-section">
        <label>Current State</label>
        <div className="orch-state">
          <div><strong>Pulse:</strong> {state.pulse}</div>
          <div><strong>Mood:</strong> {state.mood}</div>
          <div><strong>Wave:</strong> {state.wave.intensity} ({state.wave.trend})</div>
          <div><strong>Reputation:</strong> L{state.reputation.level} / {state.reputation.points}pts</div>
          <div><strong>Role:</strong> {state.identity.role}</div>
          <div><strong>Trust:</strong> {state.security.trustLevel}</div>
          <div><strong>Narrative:</strong> {state.narrative.phase}</div>
        </div>
      </div>

      <button className="orch-run-btn" onClick={orchestrator.runOnce}>
        ▶ Run Once
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIOrchestratorController.js =====

===== FILE: components\FestivalOverlayScenarioAIProfileController.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIO_AI_PROFILE_CONTROLLER_CSS */

.overlay-ai-profile-controller {
  position: fixed;
  bottom: 12px;
  left: 1360px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 260px;
  font-size: 13px;
}

.profile-details {
  margin-top: 10px;
  padding: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.profile-run-btn {
  margin-top: 12px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(80,160,255,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioAIProfileController.css =====

===== FILE: components\FestivalOverlayScenarioAIProfileController.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_PROFILE_CONTROLLER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayScenarioAIProfileController.css";
import { FestivalOverlayScenarioAIProfiles } from "../core/festivalOverlayScenarioAIProfiles";
import { generateOverlayScenarioAIWithProfile } from "../core/festivalOverlayScenarioAI";

export function FestivalOverlayScenarioAIProfileController({ runScenarioSteps, getCurrentState }) {
  const [profile, setProfile] = useState("CalmDirector");

  const selected = FestivalOverlayScenarioAIProfiles[profile];

  function runProfileScenario() {
    const state = getCurrentState();
    const steps = generateOverlayScenarioAIWithProfile(state, profile);
    runScenarioSteps(steps);
  }

  return (
    <div className="overlay-ai-profile-controller">
      <h3>AI Profile Controller</h3>

      <label>Profile</label>
      <select value={profile} onChange={(e) => setProfile(e.target.value)}>
        {Object.keys(FestivalOverlayScenarioAIProfiles).map((p) => (
          <option key={p}>{p}</option>
        ))}
      </select>

      <div className="profile-details">
        <div><strong>Speed:</strong> {selected.speed}</div>
        <div><strong>Intensity:</strong> {selected.intensity}</div>
        <div><strong>Preset Strategy:</strong> {selected.presetStrategy.name || "custom"}</div>
        <div><strong>Mode Strategy:</strong> {selected.modeStrategy.name || "custom"}</div>
        <div><strong>Notification Strategy:</strong> {selected.notificationStrategy.name || "custom"}</div>
      </div>

      <button className="profile-run-btn" onClick={runProfileScenario}>
        ▶ Run Profile Scenario
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioAIProfileController.js =====

===== FILE: components\FestivalOverlayScenarioComposer.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIOCOMPOSER_CSS */

.overlay-scenariocomposer {
  position: fixed;
  bottom: 12px;
  left: 720px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 300px;
  font-size: 13px;
}

.composer-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.step-row,
.scenario-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.clear-btn {
  margin-top: 12px;
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,80,80,0.3);
  color: #fff;
  border: none;
  cursor: pointer;
}

===== END FILE: components\FestivalOverlayScenarioComposer.css =====

===== FILE: components\FestivalOverlayScenarioComposer.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOCOMPOSER_COMPONENT
import React, { useState } from "react";
import "./FestivalOverlayScenarioComposer.css";

export function FestivalOverlayScenarioComposer({ composer, scenarioEngine }) {
  const [cmd, setCmd] = useState("setPreset");
  const [payload, setPayload] = useState("");
  const [delay, setDelay] = useState(0);
  const [scenarioName, setScenarioName] = useState("");

  return (
    <div className="overlay-scenariocomposer">
      <h3>Overlay Scenario Composer</h3>

      <div className="composer-section">
        <h4>Add Step</h4>

        <select value={cmd} onChange={(e) => setCmd(e.target.value)}>
          <option value="setPreset">setPreset</option>
          <option value="setMode">setMode</option>
          <option value="toggle">toggle</option>
          <option value="setToggles">setToggles</option>
        </select>

        <input
          type="text"
          placeholder="Payload"
          value={payload}
          onChange={(e) => setPayload(e.target.value)}
        />

        <input
          type="number"
          placeholder="Delay (ms)"
          value={delay}
          onChange={(e) => setDelay(Number(e.target.value))}
        />

        <button onClick={() => composer.addStep(cmd, payload, delay)}>
          Add Step
        </button>
      </div>

      <div className="composer-section">
        <h4>Steps</h4>
        {composer.steps.map((s, i) => (
          <div key={i} className="step-row">
            <span>{s.cmd} — {s.payload} — {s.delay}ms</span>
            <button onClick={() => composer.removeStep(i)}>✖</button>
          </div>
        ))}
      </div>

      <div className="composer-section">
        <h4>Save Scenario</h4>
        <input
          type="text"
          placeholder="Scenario name"
          value={scenarioName}
          onChange={(e) => setScenarioName(e.target.value)}
        />
        <button onClick={() => composer.saveScenario(scenarioName)}>
          Save
        </button>
      </div>

      <div className="composer-section">
        <h4>Saved Scenarios</h4>
        {Object.keys(composer.scenarios).map((name) => (
          <div key={name} className="scenario-row">
            <span>{name}</span>
            <button onClick={() => composer.loadScenario(name)}>Load</button>
            <button onClick={() => scenarioEngine.runScenario(name)}>▶ Play</button>
          </div>
        ))}
      </div>

      <button className="clear-btn" onClick={composer.clear}>
        Clear Editor
      </button>
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioComposer.js =====

===== FILE: components\FestivalOverlayScenarioEngine.css =====




/* FE_FESTIVAL_OVERLAY_SCENARIOENGINE_CSS */

.overlay-scenarioengine {
  position: fixed;
  bottom: 12px;
  left: 480px;
  padding: 12px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 9999;
  width: 240px;
  font-size: 13px;
}

.scenario-section {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.overlay-scenarioengine button {
  padding: 6px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  border: none;
  cursor: pointer;
}

.scenario-running {
  margin-top: 12px;
  opacity: 0.8;
}

===== END FILE: components\FestivalOverlayScenarioEngine.css =====

===== FILE: components\FestivalOverlayScenarioEngine.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOENGINE_COMPONENT
import React from "react";
import "./FestivalOverlayScenarioEngine.css";
import { FestivalOverlayScenarios } from "../core/festivalOverlayScenarios";

export function FestivalOverlayScenarioEngine({ scenario }) {
  return (
    <div className="overlay-scenarioengine">
      <h3>Overlay Scenario Engine</h3>

      <div className="scenario-section">
        {Object.keys(FestivalOverlayScenarios).map((name) => (
          <button key={name} onClick={() => scenario.runScenario(name)}>
            ▶ {name}
          </button>
        ))}
      </div>

      {scenario.running && (
        <div className="scenario-running">
          Running: {scenario.currentScenario}
        </div>
      )}
    </div>
  );
}

===== END FILE: components\FestivalOverlayScenarioEngine.js =====

===== FILE: components\UserCard.css =====




/* FE_FESTIVAL_USERCARD_CSS */

.usercard {
  display: flex;
  gap: 12px;
  padding: 12px;
  border-radius: 12px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
}

.usercard-avatar img {
  width: 64px;
  height: 64px;
  border-radius: 50%;
}

.usercard-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.usercard-name {
  font-size: 18px;
  font-weight: bold;
}

.usercard-handle {
  opacity: 0.7;
}

.usercard-role,
.usercard-badge {
  display: inline-block;
  padding: 2px 6px;
  margin-right: 4px;
  border-radius: 6px;
  background: rgba(255,255,255,0.1);
  font-size: 12px;
}

.usercard-trust {
  margin-top: 4px;
  font-size: 12px;
  opacity: 0.8;
}

===== END FILE: components\UserCard.css =====

===== FILE: components\UserCard.js =====




// FE_FESTIVAL_USERCARD_COMPONENT
// Live identity + badges + access widget

import React from "react";

export function UserCard({ identity, governance, security, access }) {
  if (!identity) return null;

  const avatar = identity.avatar || "/default-avatar.png";
  const name = identity.profile?.name || "Unknown User";
  const handle = identity.profile?.handle || "";
  const badges = identity.badges || [];
  const roles = governance?.roles || [];
  const trust = security?.trustLevel || "medium";

  return (
    <div className="usercard">
      <div className="usercard-avatar">
        <img src={avatar} alt="avatar" />
      </div>

      <div className="usercard-info">
        <div className="usercard-name">{name}</div>
        <div className="usercard-handle">@{handle}</div>

        <div className="usercard-roles">
          {roles.map((r) => (
            <span key={r} className="usercard-role">{r}</span>
          ))}
        </div>

        <div className="usercard-badges">
          {badges.map((b) => (
            <span key={b} className="usercard-badge">{b}</span>
          ))}
        </div>

        <div className="usercard-trust trust-" + {trust}>
          Trust: {trust}
        </div>

        <div className="usercard-access">
          <pre>{JSON.stringify(access, null, 2)}</pre>
        </div>
      </div>
    </div>
  );
}

===== END FILE: components\UserCard.js =====

===== FILE: core\economyBus.js =====




// FE_FESTIVAL_ECONOMY_BUS
// Frontend wrapper for CityEconomyEngine

let economyBus = null;

export function registerCityEconomyBus(bus) {
  economyBus = bus;
}

export function onEconomyEvent(handler) {
  if (!economyBus) return;
  economyBus.on("CITY_ECONOMY_UPDATE", handler);
}

export function offEconomyEvent(handler) {
  if (!economyBus) return;
  economyBus.off("CITY_ECONOMY_UPDATE", handler);
}

===== END FILE: core\economyBus.js =====

===== FILE: core\eventBus.js =====




// FE_FESTIVAL_EVENTBUS_CORE
// Frontend wrapper for global CityEventBus

let cityEventBus = null;

export function registerCityEventBus(bus) {
  cityEventBus = bus;
}

export function getCityEventBus() {
  return cityEventBus;
}

export function onCityEvent(type, handler) {
  if (!cityEventBus) return;
  cityEventBus.on(type, handler);
}

export function offCityEvent(type, handler) {
  if (!cityEventBus) return;
  cityEventBus.off(type, handler);
}

===== END FILE: core\eventBus.js =====

===== FILE: core\festivalAIDirectorAutoVisionEngine.js =====




// FE_FESTIVAL_AI_DIRECTOR_AUTO_VISION_ENGINE

// Tryby wizji:
export const VisionModes = {
  OFF: "OFF",
  HUD: "HUD",
  HUD_ULTRA: "HUD_ULTRA",
  VISION: "VISION"
};

// Auto‑vision logika:
export function computeVisionMode({ pulse, wave, mood, narrativePhase, trustLevel }) {
  // 1. Tryb OFF — jeśli festiwal jest w stanie spoczynku
  if (pulse < 60 && wave < 0.2) {
    return VisionModes.OFF;
  }

  // 2. Tryb HUD — normalny stan
  if (pulse < 100 && wave < 0.5 && trustLevel !== "low") {
    return VisionModes.HUD;
  }

  // 3. Tryb HUD Ultra — wysoka energia lub kreatywność
  if (pulse >= 100 || mood === "Creative" || narrativePhase === "opening") {
    return VisionModes.HUD_ULTRA;
  }

  // 4. Tryb Vision Overlay — momenty kulminacyjne
  if (
    pulse > 130 ||
    wave > 0.8 ||
    mood === "Chaotic" ||
    narrativePhase === "awards" ||
    trustLevel === "low"
  ) {
    return VisionModes.VISION;
  }

  return VisionModes.HUD;
}

===== END FILE: core\festivalAIDirectorAutoVisionEngine.js =====

===== FILE: core\festivalAIDirectorVisionOrchestrator.js =====




// FE_FESTIVAL_AI_DIRECTOR_VISION_ORCHESTRATOR

import { computeDirectorDecision } from "./director/festivalAIDirectorSystem";
import { computeVisionMode, VisionModes } from "./festivalAIDirectorAutoVisionEngine";

// Główna funkcja: spina DirectorSystem + AutoVision + UI
export function computeDirectorVisionState({
  orchestratorDecision,
  autoTunerDecision,
  scenarioDecision,
  visualDecision,
  context,
  uiState
}) {
  const director = computeDirectorDecision({
    orchestratorDecision,
    autoTunerDecision,
    scenarioDecision,
    visualDecision,
    context
  });

  const { pulse, wave, narrativePhase, trustLevel } = context || {};
  const mood = director.mood;

  const autoVision = computeVisionMode({
    pulse,
    wave,
    mood,
    narrativePhase,
    trustLevel
  });

  const visionMode = uiState?.visionModeOverride || autoVision;

  return {
    director,
    visionMode,
    autoVision,
    override: uiState?.visionModeOverride || null
  };
}

// Helper: czy dany tryb jest aktywny
export function isVisionModeActive(visionState, mode) {
  if (!visionState) return false;
  return visionState.visionMode === mode;
}

===== END FILE: core\festivalAIDirectorVisionOrchestrator.js =====

===== FILE: core\festivalEngine.js =====




// FE_FESTIVAL_ENGINE

import { FestivalHyperOrchestrator } from "./hyper/festivalHyperOrchestrator";

// Globalny silnik FESTIVAL ENGINE 2.0
export class FestivalEngine {
  constructor() {
    this.hyper = new FestivalHyperOrchestrator();
  }

  // Główna funkcja — jedna klatka festiwalu
  computeFestivalFrame({ experience, scenario, director, uiState, audience }) {
    return this.hyper.computeFrame({
      experience,
      scenario,
      director,
      uiState,
      audience
    });
  }

  // Debug snapshot
  getFestivalSnapshot() {
    return this.hyper.getSnapshot();
  }
}

===== END FILE: core\festivalEngine.js =====

===== FILE: core\festivalExperienceEngine.js =====




// FE_FESTIVAL_AI_DIRECTOR_MOOD_EXPERIENCE_INTEGRATION
import { updateDirectorMood } from "./director/festivalAIDirectorMoodEngine";

// Przykład użycia:
// const newMood = updateDirectorMood({ pulse, wave, narrativePhase, trustLevel });
// experienceState.directorMood = newMood;



// FE_FESTIVAL_PULSE_ENGINE_INTEGRATION
import { computePulse, getPulse } from "./experience/festivalPulseEngine";

// Przykład użycia:
// const pulse = computePulse({ director, scenario, visionMode, audience });
// experienceState.pulse = pulse;



// FE_FESTIVAL_WAVE_ENGINE_INTEGRATION
import { computeWave, getWave } from "./experience/festivalWaveEngine";

// Przykład użycia:
// const wave = computeWave({ pulse, director, scenario, visionMode, audience });
// experienceState.wave = wave;



// FE_FESTIVAL_EXPERIENCE_STATE_ENGINE_INTEGRATION
import { computeExperienceState } from "./experience/festivalExperienceStateEngine";

// Przykład użycia:
// const experienceState = computeExperienceState({ pulse, wave, mood, narrativePhase });
// experienceState.phase → CALM / RISING / PEAK / CHAOTIC / RECOVERY
// experienceState.intensity → 0–1
// experienceState.signature → unikalny odcisk emocjonalny



// FE_FESTIVAL_EXPERIENCE_MODIFIERS_INTEGRATION
import { computeExperienceModifiers } from "./experience/festivalExperienceModifiers";

// Przykład użycia:
// const modifiers = computeExperienceModifiers({
//   director,
//   scenario,
//   visionMode,
//   audience,
//   phase: experienceState.phase,
//   hour: systemTime.hour,
//   festivalType: config.festivalType
// });
//
// experienceState.modifiers = modifiers;



// FE_FESTIVAL_EXPERIENCE_SYNC_ENGINE_INTEGRATION
import { computeExperienceSync } from "./experience/festivalExperienceSyncEngine";

// Przykład użycia:
// const sync = computeExperienceSync({
//   director,
//   scenario,
//   audience,
//   narrativePhase,
//   visionMode,
//   uiState,
//   systemTime,
//   festivalType
// });
//
// experienceState.full = sync;



// FE_FESTIVAL_EXPERIENCE_ENGINE


// Główny interfejs Experience Engine
export function computeFestivalExperience({
  director,
  scenario,
  audience,
  narrativePhase,
  visionMode,
  uiState,
  systemTime,
  festivalType
}) {
  // 1. Pulse
  const pulse = computePulse({
    director,
    scenario,
    visionMode,
    audience
  });

  // 2. Wave
  const wave = computeWave({
    pulse,
    director,
    scenario,
    visionMode,
    audience
  });

  // 3. Experience State
  const experienceState = computeExperienceState({
    pulse,
    wave,
    mood: director?.mood,
    narrativePhase
  });

  // 4. Modifiers
  const modifiers = computeExperienceModifiers({
    director,
    scenario,
    visionMode,
    audience,
    phase: experienceState.phase,
    hour: systemTime?.hour ?? 12,
    festivalType
  });

  // 5. Full Sync (łączy Warstwę 1 + Warstwę 2)
  const sync = computeExperienceSync({
    director,
    scenario,
    audience,
    narrativePhase,
    visionMode,
    uiState,
    systemTime,
    festivalType
  });

  return {
    pulse,
    wave,
    experienceState,
    modifiers,
    sync
  };
}

// Debug helper
export function getExperienceSnapshot() {
  return {
    pulse: getPulse(),
    wave: getWave()
  };
}

===== END FILE: core\festivalExperienceEngine.js =====

===== FILE: core\festivalHyperOrchestrator.js =====




// FE_FESTIVAL_AI_DIRECTOR_MEMORY_INTEGRATION
import { rememberDirectorEvent } from "./director/festivalAIDirectorMemory";

// Przykład użycia wewnątrz HyperOrchestratora:
// rememberDirectorEvent({
//   type: "SCENARIO_DECISION",
//   profile: activeDirectorProfile,
//   mood,
//   pulse,
//   wave,
//   narrativePhase
// });



// FE_FESTIVAL_AI_DIRECTOR_MOOD_ENGINE_INTEGRATION
import { updateDirectorMood } from "./director/festivalAIDirectorMoodEngine";

// Przykład użycia:
// const mood = updateDirectorMood({ pulse, wave, narrativePhase, trustLevel });
// state.directorMood = mood;



// FE_FESTIVAL_AI_DIRECTOR_CONFLICT_RESOLVER_INTEGRATION
import { resolveDirectorConflict } from "./director/festivalAIDirectorConflictResolver";

// Przykład użycia:
// const finalDecision = resolveDirectorConflict({
//   orchestratorDecision,
//   autoTunerDecision,
//   scenarioDecision,
//   visualDecision,
//   context: { pulse, trustLevel, narrativePhase }
// });
// state.directorDecision = finalDecision;



// FE_FESTIVAL_AI_DIRECTOR_SYSTEM_INTEGRATION
import { computeDirectorDecision } from "./director/festivalAIDirectorSystem";

// Przykład użycia w HyperOrchestratorze:
// const directorResult = computeDirectorDecision({
//   orchestratorDecision,
//   autoTunerDecision,
//   scenarioDecision,
//   visualDecision,
//   context: { pulse, wave, narrativePhase, trustLevel, reputation }
// });
// state.director = directorResult;



// FE_FESTIVAL_AI_DIRECTOR_MONITOR_DIRECTOR_SYSTEM
// Przykład:
// const director = computeDirectorDecision(...);
// uiState.director = director;



// FE_FESTIVAL_AI_DIRECTOR_AUTO_VISION_INTEGRATION
import { computeVisionMode } from "./festivalAIDirectorAutoVisionEngine";

// Przykład użycia:
// const autoVision = computeVisionMode({
//   pulse,
//   wave,
//   mood: director.mood,
//   narrativePhase,
//   trustLevel
// });
// state.visionMode = manualOverride ?? autoVision;



// FE_FESTIVAL_AI_DIRECTOR_VISION_ORCHESTRATOR_INTEGRATION
import { computeDirectorVisionState } from "./festivalAIDirectorVisionOrchestrator";

// Przykład w głównym ticku:
// const visionState = computeDirectorVisionState({
//   orchestratorDecision,
//   autoTunerDecision,
//   scenarioDecision,
//   visualDecision,
//   context: { pulse, wave, narrativePhase, trustLevel, reputation },
//   uiState
// });
// state.director = visionState.director;
// state.visionMode = visionState.visionMode;

===== END FILE: core\festivalHyperOrchestrator.js =====

===== FILE: core\festivalOverlayScenarioAI.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI
// AI-like generator of overlay scenarios based on city state & narrative

/**
 * state:
 *  - pulse: number (BPM / intensity)
 *  - mood: "Calm" | "Energetic" | "Creative" | "Tense" | ...
 *  - wave: { intensity: number, trend: "rising" | "falling" | "stable" }
 *  - reputation: { level: number, points: number }
 *  - identity: { role: string, badges: string[] }
 *  - security: { trustLevel: "low" | "medium" | "high" }
 *  - narrative: { phase: string, tag?: string }
 */

export function generateOverlayScenarioAI(state) {
  const { pulse, mood, wave, reputation, identity, security, narrative } = state || {};

  const steps = [];

  // 1. Start preset based on narrative phase
  const phase = narrative?.phase || "default";

  if (phase === "opening") {
    steps.push({
      delay: 0,
      cmd: "setPreset",
      payload: mood === "Energetic" ? "Showcase" : "Minimal"
    });
  } else if (phase === "awards") {
    steps.push({
      delay: 0,
      cmd: "setPreset",
      payload: "Showcase"
    });
  } else if (phase === "jury") {
    steps.push({
      delay: 0,
      cmd: "setPreset",
      payload: "Minimal"
    });
  } else if (phase === "closing") {
    steps.push({
      delay: 0,
      cmd: "setPreset",
      payload: reputation?.level > 5 ? "Showcase" : "Minimal"
    });
  } else {
    steps.push({
      delay: 0,
      cmd: "setPreset",
      payload: "Minimal"
    });
  }

  // 2. Mode based on pulse / wave
  const baseDelay = 1200;

  if (pulse > 120 || wave?.intensity > 0.7) {
    steps.push({
      delay: baseDelay,
      cmd: "setMode",
      payload: "full"
    });
  } else if (pulse > 90 || wave?.intensity > 0.4) {
    steps.push({
      delay: baseDelay,
      cmd: "setMode",
      payload: "semi"
    });
  } else {
    steps.push({
      delay: baseDelay,
      cmd: "setMode",
      payload: "transparent"
    });
  }

  // 3. Notifications / debug based on security & role
  const role = identity?.role || "guest";
  const trust = security?.trustLevel || "medium";

  if (role === "admin" || role === "jury") {
    steps.push({
      delay: baseDelay + 1000,
      cmd: "toggle",
      payload: "debug"
    });
  }

  if (trust === "low") {
    steps.push({
      delay: baseDelay + 2000,
      cmd: "toggle",
      payload: "notifications"
    });
  } else if (trust === "high" && (phase === "opening" || phase === "awards")) {
    steps.push({
      delay: baseDelay + 2000,
      cmd: "toggle",
      payload: "notifications"
    });
  }

  // 4. Extra flair for high reputation creators
  if (reputation?.points > 1000 && role === "creator") {
    steps.push({
      delay: baseDelay + 3000,
      cmd: "setMode",
      payload: "full"
    });
  }

  // 5. Optional narrative tag tweaks
  if (narrative?.tag === "spotlight") {
    steps.push({
      delay: baseDelay + 4000,
      cmd: "toggle",
      payload: "notifications"
    });
  }

  return steps;
}

/**
 * Helper: wraps AI generator into ScenarioEngine-compatible runner.
 * You can call this from ScenarioEngine:
 *
 *   const steps = generateOverlayScenarioAI(currentState);
 *   runScenarioSteps(steps);
 */
export function buildAIScenarioFromState(state) {
  return generateOverlayScenarioAI(state);
}



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_PROFILES_INTEGRATION
import { FestivalOverlayScenarioAIProfiles } from "./festivalOverlayScenarioAIProfiles";

/**
 * AI scenario generator with profile support.
 * profileName: one of the keys from FestivalOverlayScenarioAIProfiles
 */
export function generateOverlayScenarioAIWithProfile(state, profileName) {
  const profile = FestivalOverlayScenarioAIProfiles[profileName];
  if (!profile) return generateOverlayScenarioAI(state);


  // 1. Preset
  steps.push({
    delay: 0,
    cmd: "setPreset",
    payload: profile.presetStrategy(state)
  });

  // 2. Mode
  steps.push({
    delay: 1200 * profile.speed,
    cmd: "setMode",
    payload: profile.modeStrategy(state.pulse)
  });

  // 3. Notifications
  steps.push({
    delay: 2400 * profile.speed,
    cmd: "toggle",
    payload: "notifications"
  });

  // 4. Optional debug toggle based on intensity
  if (profile.intensity > 0.7) {
    steps.push({
      delay: 3600 * profile.speed,
      cmd: "toggle",
      payload: "debug"
    });
  }

  return steps;
}

===== END FILE: core\festivalOverlayScenarioAI.js =====

===== FILE: core\festivalOverlayScenarioAIProfiles.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_PROFILES
// Director-style AI profiles that modify AI scenario generation

export const FestivalOverlayScenarioAIProfiles = {

  CalmDirector: {
    name: "CalmDirector",
    speed: 1.2,
    intensity: 0.4,
    presetStrategy: (state) =>
      state.mood === "Calm" ? "Minimal" : "Showcase",
    modeStrategy: (pulse) =>
      pulse < 80 ? "transparent" : "semi",
    notificationStrategy: (trust) =>
      trust === "high" ? false : true
  },

  AggressiveDirector: {
    name: "AggressiveDirector",
    speed: 0.7,
    intensity: 1.0,
    presetStrategy: () => "Debug",
    modeStrategy: (pulse) =>
      pulse > 100 ? "full" : "semi",
    notificationStrategy: () => true
  },

  ExperimentalDirector: {
    name: "ExperimentalDirector",
    speed: 1.0,
    intensity: 0.9,
    presetStrategy: (state) =>
      state.mood === "Creative" ? "Showcase" : "Minimal",
    modeStrategy: (pulse) =>
      pulse % 2 === 0 ? "full" : "transparent",
    notificationStrategy: () =>
      Math.random() > 0.5
  },

  CinematicDirector: {
    name: "CinematicDirector",
    speed: 1.0,
    intensity: 0.7,
    presetStrategy: (state) =>
      state.narrative?.phase === "awards" ? "Showcase" : "Minimal",
    modeStrategy: (pulse) =>
      pulse > 110 ? "full" : "semi",
    notificationStrategy: () => true
  },

  AnalyticalDirector: {
    name: "AnalyticalDirector",
    speed: 1.0,
    intensity: 0.3,
    presetStrategy: () => "Minimal",
    modeStrategy: (pulse) =>
      pulse > 120 ? "full" : pulse > 90 ? "semi" : "transparent",
    notificationStrategy: (trust) =>
      trust !== "low"
  },

  FestivalDirector: {
    name: "FestivalDirector",
    speed: 0.9,
    intensity: 0.8,
    presetStrategy: () => "Showcase",
    modeStrategy: () => "full",
    notificationStrategy: () => true
  }
};

===== END FILE: core\festivalOverlayScenarioAIProfiles.js =====

===== FILE: core\festivalOverlayScenarioLibrary.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOLIBRARY
// Professional library of festival overlay scenarios

export const FestivalOverlayScenarioLibrary = {
  // --- CEREMONIAL ---

  OpeningCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1200, cmd: "setMode", payload: "semi" },
    { delay: 2400, cmd: "toggle", payload: "notifications" },
    { delay: 3600, cmd: "toggle", payload: "debug" },
    { delay: 5000, cmd: "setMode", payload: "full" }
  ],

  ClosingCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 2000, cmd: "setMode", payload: "transparent" },
    { delay: 4000, cmd: "toggle", payload: "notifications" },
    { delay: 6000, cmd: "toggle", payload: "debug" }
  ],

  // --- ACTIVITY PEAKS ---

  PeakActivity: [
    { delay: 0, cmd: "setPreset", payload: "Debug" },
    { delay: 1500, cmd: "setMode", payload: "full" },
    { delay: 3000, cmd: "toggle", payload: "notifications" },
    { delay: 4500, cmd: "toggle", payload: "notifications" }
  ],

  CalmBeforeStorm: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "setMode", payload: "transparent" },
    { delay: 4000, cmd: "toggle", payload: "debug" }
  ],

  // --- JURY / CREATOR MODES ---

  JuryMode: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "debug" },
    { delay: 3500, cmd: "setMode", payload: "semi" }
  ],

  CreatorSpotlight: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1500, cmd: "setMode", payload: "full" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],

  // --- FESTIVAL MOMENTS ---

  AwardReveal: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1000, cmd: "setMode", payload: "full" },
    { delay: 2500, cmd: "toggle", payload: "notifications" },
    { delay: 4000, cmd: "toggle", payload: "notifications" }
  ],

  NomineeSpotlight: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 1500, cmd: "setMode", payload: "semi" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],

  JuryDeliberation: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "debug" },
    { delay: 3500, cmd: "setMode", payload: "transparent" }
  ]
};

===== END FILE: core\festivalOverlayScenarioLibrary.js =====

===== FILE: core\festivalOverlayScenarioLibraryPro.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOLIBRARY_PRO
// Extended cinematic library of overlay scenarios

export const FestivalOverlayScenarioLibraryPro = {

  // === CEREMONIAL ===

  OpeningCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1200, cmd: "setMode", payload: "semi" },
    { delay: 2400, cmd: "toggle", payload: "notifications" },
    { delay: 3600, cmd: "toggle", payload: "debug" },
    { delay: 5000, cmd: "setMode", payload: "full" }
  ],

  GrandOpening: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 800, cmd: "setMode", payload: "transparent" },
    { delay: 1600, cmd: "toggle", payload: "notifications" },
    { delay: 2400, cmd: "setMode", payload: "semi" },
    { delay: 4000, cmd: "setMode", payload: "full" }
  ],

  ClosingCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 2000, cmd: "setMode", payload: "transparent" },
    { delay: 4000, cmd: "toggle", payload: "notifications" },
    { delay: 6000, cmd: "toggle", payload: "debug" }
  ],

  FinalCurtain: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 1500, cmd: "setMode", payload: "transparent" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],


  // === ACTIVITY PEAKS ===

  PeakActivity: [
    { delay: 0, cmd: "setPreset", payload: "Debug" },
    { delay: 1500, cmd: "setMode", payload: "full" },
    { delay: 3000, cmd: "toggle", payload: "notifications" },
    { delay: 4500, cmd: "toggle", payload: "notifications" }
  ],

  SurgeMode: [
    { delay: 0, cmd: "setPreset", payload: "Debug" },
    { delay: 1000, cmd: "setMode", payload: "full" },
    { delay: 2000, cmd: "toggle", payload: "debug" }
  ],

  CalmBeforeStorm: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "setMode", payload: "transparent" },
    { delay: 4000, cmd: "toggle", payload: "debug" }
  ],

  AfterpartyPulse: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1500, cmd: "setMode", payload: "semi" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],


  // === JURY / CREATOR MODES ===

  JuryMode: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "debug" },
    { delay: 3500, cmd: "setMode", payload: "semi" }
  ],

  JuryDeliberation: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "debug" },
    { delay: 3500, cmd: "setMode", payload: "transparent" }
  ],

  JuryFocus: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 1500, cmd: "setMode", payload: "transparent" }
  ],

  CreatorSpotlight: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1500, cmd: "setMode", payload: "full" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],

  CreatorStudio: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "setMode", payload: "semi" }
  ],


  // === FESTIVAL MOMENTS ===

  AwardReveal: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1000, cmd: "setMode", payload: "full" },
    { delay: 2500, cmd: "toggle", payload: "notifications" },
    { delay: 4000, cmd: "toggle", payload: "notifications" }
  ],

  NomineeSpotlight: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 1500, cmd: "setMode", payload: "semi" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],

  PressConference: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 2000, cmd: "setMode", payload: "semi" },
    { delay: 3500, cmd: "toggle", payload: "debug" }
  ],

  BackstageMode: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "notifications" }
  ],

  RedCarpetMode: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1200, cmd: "setMode", payload: "full" }
  ],


  // === SPECIAL / SYSTEM ===

  EmergencyBroadcast: [
    { delay: 0, cmd: "setPreset", payload: "Debug" },
    { delay: 800, cmd: "setMode", payload: "full" },
    { delay: 1600, cmd: "toggle", payload: "notifications" },
    { delay: 2400, cmd: "toggle", payload: "notifications" }
  ],

  SilentMode: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 1000, cmd: "setMode", payload: "transparent" },
    { delay: 2000, cmd: "toggle", payload: "notifications" },
    { delay: 3000, cmd: "toggle", payload: "debug" }
  ]
};

===== END FILE: core\festivalOverlayScenarioLibraryPro.js =====

===== FILE: core\festivalOverlayScenarioLibraryUltra.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOLIBRARY_ULTRA
// Adaptive, dynamic overlay scenarios reacting to live city state

export const FestivalOverlayScenarioLibraryUltra = {

  // === ADAPTIVE CEREMONIAL ===

  AdaptiveOpening: (state) => {
    const { pulse, mood } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: mood === "Energetic" ? "Showcase" : "Minimal" },
      { delay: 1200, cmd: "setMode", payload: pulse > 110 ? "full" : "semi" },
      { delay: 2400, cmd: "toggle", payload: "notifications" },
      { delay: 3600, cmd: "toggle", payload: "debug" }
    ];
  },

  AdaptiveClosing: (state) => {
    const { pulse, reputation } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: reputation?.level > 5 ? "Showcase" : "Minimal" },
      { delay: 2000, cmd: "setMode", payload: pulse < 80 ? "transparent" : "semi" },
      { delay: 4000, cmd: "toggle", payload: "notifications" }
    ];
  },


  // === ADAPTIVE ACTIVITY MODES ===

  DynamicPeak: (state) => {
    const { wave, pulse } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: "Debug" },
      { delay: 1000, cmd: "setMode", payload: pulse > 120 ? "full" : "semi" },
      { delay: 2000, cmd: "toggle", payload: wave?.intensity > 0.7 ? "notifications" : "debug" }
    ];
  },

  SocialSurge: (state) => {
    const { wave } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: "Showcase" },
      { delay: 1500, cmd: "setMode", payload: wave?.intensity > 0.5 ? "full" : "semi" },
      { delay: 3000, cmd: "toggle", payload: "notifications" }
    ];
  },


  // === ADAPTIVE JURY / CREATOR MODES ===

  JuryAdaptive: (state) => {
    const { identity, security } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: identity?.role === "jury" ? "Minimal" : "Showcase" },
      { delay: 2000, cmd: "setMode", payload: security?.trustLevel === "high" ? "semi" : "transparent" }
    ];
  },

  CreatorAdaptive: (state) => {
    const { reputation } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: reputation?.points > 500 ? "Showcase" : "Minimal" },
      { delay: 1500, cmd: "setMode", payload: reputation?.level > 3 ? "full" : "semi" }
    ];
  },


  // === ADAPTIVE FESTIVAL MOMENTS ===

  AwardAdaptive: (state) => {
    const { mood, wave } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: mood === "Creative" ? "Showcase" : "Minimal" },
      { delay: 1500, cmd: "setMode", payload: wave?.intensity > 0.6 ? "full" : "semi" },
      { delay: 3000, cmd: "toggle", payload: "notifications" }
    ];
  },

  SpotlightAdaptive: (state) => {
    const { identity } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: identity?.badges?.length > 3 ? "Showcase" : "Minimal" },
      { delay: 2000, cmd: "setMode", payload: "full" }
    ];
  },


  // === ADAPTIVE SYSTEM MODES ===

  EmergencyAdaptive: (state) => {
    const { security } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: "Debug" },
      { delay: 800, cmd: "setMode", payload: security?.trustLevel === "low" ? "full" : "semi" },
      { delay: 1600, cmd: "toggle", payload: "notifications" }
    ];
  },

  SilentAdaptive: (state) => {
    const { pulse } = state;

    return [
      { delay: 0, cmd: "setPreset", payload: "Minimal" },
      { delay: 1000, cmd: "setMode", payload: pulse < 70 ? "transparent" : "semi" },
      { delay: 2000, cmd: "toggle", payload: "notifications" }
    ];
  }
};

===== END FILE: core\festivalOverlayScenarioLibraryUltra.js =====

===== FILE: core\festivalOverlayScenarios.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOS
// High-level overlay scenarios with timed steps

export const FestivalOverlayScenarios = {
  OpeningCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1000, cmd: "toggle", payload: "notifications" },
    { delay: 2000, cmd: "toggle", payload: "debug" },
    { delay: 3000, cmd: "setMode", payload: "full" }
  ],

  PeakActivity: [
    { delay: 0, cmd: "setPreset", payload: "Debug" },
    { delay: 1500, cmd: "setMode", payload: "full" },
    { delay: 3000, cmd: "toggle", payload: "notifications" }
  ],

  JuryMode: [
    { delay: 0, cmd: "setPreset", payload: "Minimal" },
    { delay: 2000, cmd: "toggle", payload: "debug" }
  ],

  ClosingCeremony: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 2000, cmd: "setMode", payload: "transparent" },
    { delay: 4000, cmd: "toggle", payload: "notifications" }
  ],

  CreatorSpotlight: [
    { delay: 0, cmd: "setPreset", payload: "Showcase" },
    { delay: 1500, cmd: "setMode", payload: "full" }
  ]
};

===== END FILE: core\festivalOverlayScenarios.js =====

===== FILE: core\festivalScenarioEngine.js =====

// FE_FESTIVAL_SCENARIO_LIBRARY_INTEGRATION
import { ScenarioLibrary, ScenarioSequences, NarrativeArcs } from "./scenario/festivalScenarioLibrary";

// FE_FESTIVAL_SCENARIO_STATE_INTEGRATION
import {
  ScenarioState,
  resetScenarioState,
  setActiveScene,
  setActiveSequence,
  setNarrativePhase,
  updateSceneDuration,
  setTrigger,
  resetTriggers
} from "./scenario/festivalScenarioState";

// FE_FESTIVAL_SCENARIO_TRIGGERS_INTEGRATION
import { computeScenarioTriggers } from "./scenario/festivalScenarioTriggers";

// FE_FESTIVAL_SCENARIO_RESOLVER_INTEGRATION
import { resolveScenario } from "./scenario/festivalScenarioResolver";

// FE_FESTIVAL_SCENARIO_ORCHESTRATOR_INTEGRATION
import { computeScenarioOrchestration } from "./scenario/festivalScenarioOrchestrator";


// FE_FESTIVAL_SCENARIO_ENGINE

// Główna funkcja Scenario Engine
export function computeFestivalScenario({
  pulse,
  wave,
  mood,
  audience,
  narrativePhase,
  manual
}) {
  // 1. Orkiestracja dramaturgii
  const orchestration = computeScenarioOrchestration({
    pulse,
    wave,
    mood,
    audience,
    narrativePhase,
    manual
  });

  // 2. Aktualizacja narrative phase (jeśli potrzebne)
  if (narrativePhase && ScenarioState.narrativePhase !== narrativePhase) {
    setNarrativePhase(narrativePhase);
  }

  return {
    activeScene: ScenarioState.activeScene,
    activeSequence: ScenarioState.activeSequence,
    narrativePhase: ScenarioState.narrativePhase,
    sceneDuration: ScenarioState.sceneDuration,
    triggers: orchestration.triggers,
    changed: orchestration.changed
  };
}

// Debug snapshot
export function getScenarioSnapshot() {
  return {
    activeScene: ScenarioState.activeScene,
    activeSequence: ScenarioState.activeSequence,
    narrativePhase: ScenarioState.narrativePhase,
    sceneDuration: ScenarioState.sceneDuration,
    history: ScenarioState.history
  };
}

===== END FILE: core\festivalScenarioEngine.js =====

===== FILE: core\festivalUIState.js =====




// FE_FESTIVAL_AI_DIRECTOR_AUTO_VISION_SWITCHER
// UI może ustawić manualOverride:
// uiState.visionModeOverride = "HUD_ULTRA";
// auto‑vision działa tylko gdy override = null

===== END FILE: core\festivalUIState.js =====

===== FILE: core\festivalVisualEngine.js =====




// FE_FESTIVAL_VISION_OVERLAY_ENGINE_INTEGRATION
import { computeOverlayVisuals } from "./visual/festivalVisionOverlayEngine";

// Przykład użycia:
// const overlay = computeOverlayVisuals({ pulse, wave, phase, scene, directorMood });



// FE_FESTIVAL_HUD_SYSTEM_INTEGRATION
import { computeHUDVisuals } from "./visual/festivalHUDSystem";

// Przykład użycia:
// const hud = computeHUDVisuals({ pulse, wave, overlayMode, scene });



// FE_FESTIVAL_VISUAL_EFFECTS_ENGINE_INTEGRATION
import { computeVisualEffects } from "./visual/festivalVisualEffectsEngine";

// Przykład użycia:
// const effects = computeVisualEffects({ pulse, wave, phase, overlayMode, scene, directorMood });



// FE_FESTIVAL_VISUAL_SYNC_ENGINE_INTEGRATION
import { computeVisualSync } from "./visual/festivalVisualSyncEngine";

// Przykład użycia:
// const visual = computeVisualSync({
//   pulse,
//   wave,
//   phase,
//   scene,
//   directorMood
// });
//
// visual.overlay.mode
// visual.hud.mode
// visual.effects



// FE_FESTIVAL_VISUAL_ORCHESTRATOR_INTEGRATION
import { computeVisualOrchestration } from "./visual/festivalVisualOrchestrator";

// Przykład użycia:
// const visualOrchestration = computeVisualOrchestration({
//   experience: experienceState.full,
//   scenario: scenarioState,
//   director,
//   uiState
// });
//
// visualOrchestration.overlay
// visualOrchestration.hud
// visualOrchestration.effects



// FE_FESTIVAL_VISUAL_ENGINE


// Główne API Warstwy 4
export function computeFestivalVisuals({
  experience,
  scenario,
  director,
  uiState
}) {
  return computeVisualOrchestration({
    experience,
    scenario,
    director,
    uiState
  });
}

// Debug snapshot
export function getVisualSnapshot({
  experience,
  scenario,
  director,
  uiState
}) {
  const visual = computeFestivalVisuals({
    experience,
    scenario,
    director,
    uiState
  });

  return {
    pulse: visual.pulse,
    wave: visual.wave,
    phase: visual.phase,
    scene: visual.scene,
    directorMood: visual.directorMood,
    overlayMode: visual.overlay.mode,
    hudMode: visual.hud.mode
  };
}

===== END FILE: core\festivalVisualEngine.js =====

===== FILE: core\governanceBus.js =====




// FE_FESTIVAL_GOVERNANCE_BUS
// Frontend wrapper for CityGovernanceEngine

let governanceBus = null;

export function registerCityGovernanceBus(bus) {
  governanceBus = bus;
}

export function onGovernanceEvent(handler) {
  if (!governanceBus) return;
  governanceBus.on("CITY_GOVERNANCE_UPDATE", handler);
}

export function offGovernanceEvent(handler) {
  if (!governanceBus) return;
  governanceBus.off("CITY_GOVERNANCE_UPDATE", handler);
}

===== END FILE: core\governanceBus.js =====

===== FILE: core\identityBus.js =====




// FE_FESTIVAL_IDENTITY_BUS
// Frontend wrapper for CityIdentityEngine

let identityBus = null;

export function registerCityIdentityBus(bus) {
  identityBus = bus;
}

export function onIdentityEvent(handler) {
  if (!identityBus) return;
  identityBus.on("CITY_IDENTITY_UPDATE", handler);
}

export function offIdentityEvent(handler) {
  if (!identityBus) return;
  identityBus.off("CITY_IDENTITY_UPDATE", handler);
}

===== END FILE: core\identityBus.js =====

===== FILE: core\narrativeBus.js =====




// FE_FESTIVAL_NARRATIVE_BUS
// Frontend wrapper for CityNarrativeEngine event bus

let narrativeBus = null;

export function registerCityNarrativeBus(bus) {
  narrativeBus = bus;
}

export function onNarrativeEvent(handler) {
  if (!narrativeBus) return;
  narrativeBus.on("CITY_NARRATIVE_EVENT", handler);
}

export function offNarrativeEvent(handler) {
  if (!narrativeBus) return;
  narrativeBus.off("CITY_NARRATIVE_EVENT", handler);
}

===== END FILE: core\narrativeBus.js =====

===== FILE: core\overlayPresets.js =====




// FE_FESTIVAL_OVERLAY_PRESETS
export const FestivalOverlayPresets = {
  Debug: {
    mode: "full",
    toggles: {
      hud: true,
      notifications: true,
      debug: true
    }
  },

  Showcase: {
    mode: "semi",
    toggles: {
      hud: true,
      notifications: true,
      debug: false
    }
  },

  Minimal: {
    mode: "transparent",
    toggles: {
      hud: true,
      notifications: false,
      debug: false
    }
  }
};

===== END FILE: core\overlayPresets.js =====

===== FILE: core\pulseMoodBus.js =====




// FE_FESTIVAL_PULSE_MOOD_BUS
// Frontend wrapper for CityPulseEngine & CityMoodEngine

let pulseBus = null;
let moodBus = null;

export function registerCityPulseBus(bus) {
  pulseBus = bus;
}

export function registerCityMoodBus(bus) {
  moodBus = bus;
}

export function onPulseEvent(handler) {
  if (!pulseBus) return;
  pulseBus.on("CITY_PULSE_UPDATE", handler);
}

export function onMoodEvent(handler) {
  if (!moodBus) return;
  moodBus.on("CITY_MOOD_UPDATE", handler);
}

export function offPulseEvent(handler) {
  if (!pulseBus) return;
  pulseBus.off("CITY_PULSE_UPDATE", handler);
}

export function offMoodEvent(handler) {
  if (!moodBus) return;
  moodBus.off("CITY_MOOD_UPDATE", handler);
}

===== END FILE: core\pulseMoodBus.js =====

===== FILE: core\reputationBus.js =====




// FE_FESTIVAL_REPUTATION_BUS
// Frontend wrapper for CityReputationEngine

let reputationBus = null;

export function registerCityReputationBus(bus) {
  reputationBus = bus;
}

export function onReputationEvent(handler) {
  if (!reputationBus) return;
  reputationBus.on("CITY_REPUTATION_UPDATE", handler);
}

export function offReputationEvent(handler) {
  if (!reputationBus) return;
  reputationBus.off("CITY_REPUTATION_UPDATE", handler);
}

===== END FILE: core\reputationBus.js =====

===== FILE: core\securityBus.js =====




// FE_FESTIVAL_SECURITY_BUS
// Frontend wrapper for CitySecurityEngine

let securityBus = null;

export function registerCitySecurityBus(bus) {
  securityBus = bus;
}

export function onSecurityEvent(handler) {
  if (!securityBus) return;
  securityBus.on("CITY_SECURITY_UPDATE", handler);
}

export function offSecurityEvent(handler) {
  if (!securityBus) return;
  securityBus.off("CITY_SECURITY_UPDATE", handler);
}

===== END FILE: core\securityBus.js =====

===== FILE: core\simulationBus.js =====




// FE_FESTIVAL_SIMULATION_BUS
// Frontend wrapper for CitySimulationEngine & CityEmergenceEngine

let simulationBus = null;
let emergenceBus = null;

export function registerCitySimulationBus(bus) {
  simulationBus = bus;
}

export function registerCityEmergenceBus(bus) {
  emergenceBus = bus;
}

export function onSimulationEvent(handler) {
  if (!simulationBus) return;
  simulationBus.on("CITY_SIMULATION_WAVE", handler);
}

export function onEmergenceEvent(handler) {
  if (!emergenceBus) return;
  emergenceBus.on("CITY_EMERGENCE_PATTERN", handler);
}

export function offSimulationEvent(handler) {
  if (!simulationBus) return;
  simulationBus.off("CITY_SIMULATION_WAVE", handler);
}

export function offEmergenceEvent(handler) {
  if (!emergenceBus) return;
  emergenceBus.off("CITY_EMERGENCE_PATTERN", handler);
}

===== END FILE: core\simulationBus.js =====

===== FILE: core\useAdminAccessPanel.js =====




// FE_FESTIVAL_ADMIN_ACCESS_HOOK
// Hook for AdminAccessPanel integration

import { useUserCardData } from "./useUserCardData";

export function useAdminAccessPanel(identity, governance, security) {
  const usercard = useUserCardData(identity, governance, security);
  return usercard;
}

===== END FILE: core\useAdminAccessPanel.js =====

===== FILE: core\useFestivalAccess.js =====




// FE_FESTIVAL_ACCESS_HOOK
// React hook for evaluating access in real time

import { useState, useEffect } from "react";
import { evaluateFestivalAccess } from "../access/accessEvaluator";

export function useFestivalAccess(identity, governance, security) {
  const [access, setAccess] = useState({});

  useEffect(() => {
    const a = evaluateFestivalAccess(identity, governance, security);
    setAccess(a);
  }, [identity, governance, security]);

  return access;
}

===== END FILE: core\useFestivalAccess.js =====

===== FILE: core\useFestivalDebugConsole.js =====




// FE_FESTIVAL_DEBUG_CONSOLE_HOOK
// Collects live logs from all engines for FestivalDebugConsole

import { useState } from "react";
import { useFestivalPulseMoodLive } from "./useFestivalPulseMoodLive";
import { useFestivalSimulationLive } from "./useFestivalSimulationLive";
import { useFestivalReputationLive } from "./useFestivalReputationLive";
import { useFestivalGovernanceLive } from "./useFestivalGovernanceLive";
import { useFestivalSecurityLive } from "./useFestivalSecurityLive";
import { useFestivalIdentityLive } from "./useFestivalIdentityLive";
import { useFestivalEconomyLive } from "./useFestivalEconomyLive";

function now() {
  return new Date().toISOString().split("T")[1].slice(0, 8);
}

export function useFestivalDebugConsole() {
  const [logs, setLogs] = useState([]);
  const [collapsed, setCollapsed] = useState(true);

  function push(source, message, payload) {
    setLogs((prev) => [
      {
        time: now(),
        source,
        message,
        payload
      },
      ...prev
    ].slice(0, 200));
  }

  // Pulse + Mood
  useFestivalPulseMoodLive(
    (bpm) => push("pulse", "Pulse update: " + bpm, { bpm }),
    (mood) => push("mood", "Mood update: " + mood, { mood })
  );

  // Simulation + Emergence
  useFestivalSimulationLive(
    (wave) => push("simulation", "Wave: " + (wave?.label || "?"), wave),
    (pattern) => push("simulation", "Pattern: " + (pattern?.type || "?"), pattern)
  );

  // Reputation
  useFestivalReputationLive((rep) =>
    push("reputation", "Reputation update for " + rep.userId, rep)
  );

  // Governance
  useFestivalGovernanceLive((gov) =>
    push("governance", "Governance update for " + gov.userId, gov)
  );

  // Security
  useFestivalSecurityLive((sec) =>
    push("security", "Security update for " + sec.userId, sec)
  );

  // Identity
  useFestivalIdentityLive((id) =>
    push("identity", "Identity update for " + id.userId, id)
  );

  // Economy
  useFestivalEconomyLive((eco) =>
    push("economy", "Economy update for " + eco.userId, eco)
  );

  function toggle() {
    setCollapsed((c) => !c);
  }

  return {
    logs,
    collapsed,
    toggle
  };
}

===== END FILE: core\useFestivalDebugConsole.js =====

===== FILE: core\useFestivalEconomyLive.js =====




// FE_FESTIVAL_ECONOMY_HOOK
// React hook for live economy updates

import { useEffect } from "react";
import { attachFestivalEconomyLiveSync } from "../live/festivalEconomyLiveSync";

export function useFestivalEconomyLive(onEconomy) {
  useEffect(() => {
    attachFestivalEconomyLiveSync((eco) => {
      onEconomy(eco);
    });
  }, []);
}

===== END FILE: core\useFestivalEconomyLive.js =====

===== FILE: core\useFestivalGovernanceLive.js =====




// FE_FESTIVAL_GOVERNANCE_HOOK
// React hook for live governance updates

import { useEffect } from "react";
import { attachFestivalGovernanceLiveSync } from "../live/festivalGovernanceLiveSync";

export function useFestivalGovernanceLive(onGov) {
  useEffect(() => {
    attachFestivalGovernanceLiveSync((gov) => {
      onGov(gov);
    });
  }, []);
}

===== END FILE: core\useFestivalGovernanceLive.js =====

===== FILE: core\useFestivalHUD.js =====




// FE_FESTIVAL_HUD_HOOK
// Combines pulse + mood + wave + reputation + identity + access into HUD data

import { useFestivalPulseMoodLive } from "./useFestivalPulseMoodLive";
import { useFestivalSimulationLive } from "./useFestivalSimulationLive";
import { useFestivalReputationLive } from "./useFestivalReputationLive";
import { useFestivalIdentityLive } from "./useFestivalIdentityLive";
import { useFestivalAccess } from "./useFestivalAccess";

import { useState } from "react";

export function useFestivalHUD(identity, governance, security) {
  const [pulse, setPulse] = useState(0);
  const [mood, setMood] = useState("Calm");
  const [wave, setWave] = useState(null);
  const [pattern, setPattern] = useState(null);
  const [reputation, setReputation] = useState({});
  const [identityLive, setIdentityLive] = useState(identity);

  // Pulse + Mood
  useFestivalPulseMoodLive(
    (bpm) => setPulse(bpm),
    (m) => setMood(m)
  );

  // Simulation waves
  useFestivalSimulationLive(
    (w) => setWave(w),
    (p) => setPattern(p)
  );

  // Reputation
  useFestivalReputationLive((rep) => setReputation(rep));

  // Identity
  useFestivalIdentityLive((id) => setIdentityLive(id));

  // Access
  const access = useFestivalAccess(identityLive, governance, security);

  return {
    pulse,
    mood,
    wave,
    reputation,
    identity: identityLive,
    access
  };
}

===== END FILE: core\useFestivalHUD.js =====

===== FILE: core\useFestivalIdentityLive.js =====




// FE_FESTIVAL_IDENTITY_HOOK
// React hook for live identity updates

import { useEffect } from "react";
import { attachFestivalIdentityLiveSync } from "../live/festivalIdentityLiveSync";

export function useFestivalIdentityLive(onIdentity) {
  useEffect(() => {
    attachFestivalIdentityLiveSync((id) => {
      onIdentity(id);
    });
  }, []);
}

===== END FILE: core\useFestivalIdentityLive.js =====

===== FILE: core\useFestivalLive.js =====




// FE_FESTIVAL_LIVE_HOOK
// React hook for live updates in Festival Pavilion

import { useEffect } from "react";
import { attachFestivalLiveSync } from "../live/festivalLiveSync";

export function useFestivalLive(onEvent) {
  useEffect(() => {
    attachFestivalLiveSync((ev) => {
      onEvent(ev);
    });
  }, []);
}

===== END FILE: core\useFestivalLive.js =====

===== FILE: core\useFestivalNarrativeLive.js =====




// FE_FESTIVAL_NARRATIVE_HOOK
// React hook for live narrative updates in Festival Pavilion

import { useEffect } from "react";
import { attachFestivalNarrativeLiveSync } from "../live/festivalNarrativeLiveSync";

export function useFestivalNarrativeLive(onStory) {
  useEffect(() => {
    attachFestivalNarrativeLiveSync((story) => {
      onStory(story);
    });
  }, []);
}

===== END FILE: core\useFestivalNarrativeLive.js =====

===== FILE: core\useFestivalNotifications.js =====




// FE_FESTIVAL_NOTIFICATIONS_HOOK
import { useState } from "react";
import { useFestivalPulseMoodLive } from "./useFestivalPulseMoodLive";
import { useFestivalSimulationLive } from "./useFestivalSimulationLive";
import { useFestivalReputationLive } from "./useFestivalReputationLive";
import { useFestivalGovernanceLive } from "./useFestivalGovernanceLive";
import { useFestivalSecurityLive } from "./useFestivalSecurityLive";
import { useFestivalIdentityLive } from "./useFestivalIdentityLive";
import { useFestivalEconomyLive } from "./useFestivalEconomyLive";

export function useFestivalNotifications() {
  const [notifications, setNotifications] = useState([]);

  function push(type, title, message) {
    setNotifications((prev) => [
      { type, title, message },
      ...prev.slice(0, 20)
    ]);
  }

  useFestivalPulseMoodLive(
    (bpm) => push("pulse", "Pulse Update", "City BPM: " + bpm),
    (mood) => push("pulse", "Mood Shift", "City mood is now: " + mood)
  );

  useFestivalSimulationLive(
    (wave) => push("simulation", "Activity Wave", wave.label || "Unknown wave"),
    (pattern) => push("simulation", "Emergent Pattern", pattern.type)
  );

  useFestivalReputationLive((rep) =>
    push("reputation", "Reputation Update", "User " + rep.userId + " changed reputation")
  );

  useFestivalGovernanceLive((gov) =>
    push("governance", "Governance Update", "Roles updated for " + gov.userId)
  );

  useFestivalSecurityLive((sec) =>
    push("security", "Security Alert", "Trust level: " + sec.trustLevel)
  );

  useFestivalIdentityLive((id) =>
    push("identity", "Identity Update", "Profile updated for " + id.userId)
  );

  useFestivalEconomyLive((eco) =>
    push("economy", "Transaction", eco.delta + " tokens (" + eco.reason + ")")
  );

  return notifications;
}

===== END FILE: core\useFestivalNotifications.js =====

===== FILE: core\useFestivalOverlay.js =====




// FE_FESTIVAL_OVERLAY_HOOK
import { useFestivalHUD } from "./useFestivalHUD";
import { useFestivalDebugConsole } from "./useFestivalDebugConsole";
import { useFestivalNotifications } from "./useFestivalNotifications";

export function useFestivalOverlay(identity, governance, security) {
  const hud = useFestivalHUD(identity, governance, security);
  const debug = useFestivalDebugConsole();
  const notifications = useFestivalNotifications();

  return {
    hud,
    debug,
    notifications,
    mode: "semi"
  };
}

===== END FILE: core\useFestivalOverlay.js =====

===== FILE: core\useFestivalOverlayController.js =====




// FE_FESTIVAL_OVERLAY_CONTROLLER_HOOK
import { useState } from "react";

export function useFestivalOverlayController() {
  const [mode, setMode] = useState("semi");

  const [toggles, setToggles] = useState({
    hud: true,
    notifications: true,
    debug: true
  });

  return {
    mode,
    setMode,
    toggles,
    setToggles
  };
}

===== END FILE: core\useFestivalOverlayController.js =====

===== FILE: core\useFestivalOverlayMacroRecorder.js =====




// FE_FESTIVAL_OVERLAY_MACRORECORDER_HOOK
// Records and plays back overlay commands

import { useState, useRef } from "react";

export function useFestivalOverlayMacroRecorder(presetManager, controller) {
  const [recording, setRecording] = useState(false);
  const [macros, setMacros] = useState({});
  const [currentMacroName, setCurrentMacroName] = useState(null);

  const buffer = useRef([]);

  function startRecording(name) {
    setRecording(true);
    setCurrentMacroName(name);
    buffer.current = [];
  }

  function stopRecording() {
    setRecording(false);
    if (!currentMacroName) return;

    setMacros((prev) => ({
      ...prev,
      [currentMacroName]: [...buffer.current]
    }));

    buffer.current = [];
    setCurrentMacroName(null);
  }

  function recordCommand(cmd, payload) {
    if (!recording) return;

    buffer.current.push({
      time: Date.now(),
      cmd,
      payload
    });
  }

  async function playMacro(name) {
    const macro = macros[name];
    if (!macro) return;

    let lastTime = macro[0]?.time || 0;

    for (const step of macro) {
      const delay = step.time - lastTime;
      lastTime = step.time;

      await new Promise((res) => setTimeout(res, delay));

      execute(step.cmd, step.payload);
    }
  }

  function execute(cmd, payload) {
    switch (cmd) {
      case "setPreset":
        presetManager.applyPreset(payload);
        break;

      case "setMode":
        controller.setMode(payload);
        break;

      case "toggle":
        controller.setToggles({
          ...controller.toggles,
          [payload]: !controller.toggles[payload]
        });
        break;

      case "setToggles":
        controller.setToggles(payload);
        break;

      default:
        console.warn("MacroRecorder: unknown command", cmd);
    }
  }

  return {
    recording,
    macros,
    startRecording,
    stopRecording,
    recordCommand,
    playMacro
  };
}

===== END FILE: core\useFestivalOverlayMacroRecorder.js =====

===== FILE: core\useFestivalOverlayPresetManager.js =====




// FE_FESTIVAL_OVERLAY_PRESET_MANAGER_HOOK
import { useState } from "react";
import { FestivalOverlayPresets } from "./overlayPresets";

export function useFestivalOverlayPresetManager(controller) {
  const [customPresets, setCustomPresets] = useState({});

  function applyPreset(name) {
    const preset =
      FestivalOverlayPresets[name] || customPresets[name];

    if (!preset) return;

    controller.setMode(preset.mode);
    controller.setToggles(preset.toggles);
  }

  function savePreset(name) {
    const newPreset = {
      mode: controller.mode,
      toggles: controller.toggles
    };

    setCustomPresets((prev) => ({
      ...prev,
      [name]: newPreset
    }));
  }

  return {
    applyPreset,
    savePreset,
    customPresets
  };
}



// FE_FESTIVAL_OVERLAY_PRESET_MANAGER_EXTENDED

// Add refs for sync
import { useRef } from "react";

customPresetsRef.current = customPresets;

// Track last applied preset
const [lastPreset, setLastPreset] = useState(null);

    FestivalOverlayPresets[name] || customPresets[name];

  if (!preset) return;

  controller.setMode(preset.mode);
  controller.setToggles(preset.toggles);
  setLastPreset(name);
}

function mergeRemotePresets(remote) {
  setCustomPresets((prev) => ({
    ...prev,
    ...remote
  }));
}

return {
  applyPreset,
  savePreset,
  customPresets,
  customPresetsRef,
  lastPreset,
  mergeRemotePresets
};

===== END FILE: core\useFestivalOverlayPresetManager.js =====

===== FILE: core\useFestivalOverlayPresetSync.js =====




// FE_FESTIVAL_OVERLAY_PRESET_SYNC_HOOK
// Syncs overlay presets with LocalStorage and optionally user profile

import { useEffect } from "react";

const LS_KEY = "FE01_FESTIVAL_OVERLAY_PRESETS";
const LS_LAST_KEY = "FE01_FESTIVAL_OVERLAY_LAST_PRESET";

export function useFestivalOverlayPresetSync(presetManager, controller, identity) {
  // Load presets from LocalStorage
  useEffect(() => {
    try {
      const saved = localStorage.getItem(LS_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        presetManager.customPresetsRef.current = parsed;
      }

      const last = localStorage.getItem(LS_LAST_KEY);
      if (last) {
        presetManager.applyPreset(last);
      }
    } catch (e) {
      console.warn("OverlayPresetSync load error:", e);
    }
  }, []);

  // Save presets to LocalStorage whenever they change
  useEffect(() => {
    try {
      localStorage.setItem(
        LS_KEY,
        JSON.stringify(presetManager.customPresetsRef.current)
      );
    } catch (e) {
      console.warn("OverlayPresetSync save error:", e);
    }
  }, [presetManager.customPresets]);

  // Save last used preset
  useEffect(() => {
    try {
      localStorage.setItem(LS_LAST_KEY, presetManager.lastPreset);
    } catch (e) {
      console.warn("OverlayPresetSync last preset error:", e);
    }
  }, [presetManager.lastPreset]);

  // OPTIONAL: Sync with user profile (CityIdentityEngine)
  // If identity.profile.settings.overlayPresets exists → load/merge
  useEffect(() => {
    if (!identity?.profile?.settings?.overlayPresets) return;

    const remote = identity.profile.settings.overlayPresets;
    presetManager.mergeRemotePresets(remote);
  }, [identity]);
}

===== END FILE: core\useFestivalOverlayPresetSync.js =====

===== FILE: core\useFestivalOverlayQuickSwitch.js =====




// FE_FESTIVAL_OVERLAY_QUICKSWITCH_HOOK
// Keyboard shortcuts for overlay presets: F10, F11, F12

import { useEffect } from "react";

export function useFestivalOverlayQuickSwitch(presetManager) {
  useEffect(() => {
    function handler(e) {
      if (e.key === "F10") {
        presetManager.applyPreset("Debug");
      }
      if (e.key === "F11") {
        presetManager.applyPreset("Showcase");
      }
      if (e.key === "F12") {
        presetManager.applyPreset("Minimal");
      }
    }

    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [presetManager]);
}

===== END FILE: core\useFestivalOverlayQuickSwitch.js =====

===== FILE: core\useFestivalOverlayRemoteControl.js =====




// FE_FESTIVAL_OVERLAY_REMOTECONTROL_HOOK
// Remote control for overlay via WebSocket / CityAdminEngine

import { useEffect } from "react";

export function useFestivalOverlayRemoteControl(presetManager, controller, wsUrl = "ws://localhost:8080") {
  useEffect(() => {
    let ws;

    try {
      ws = new WebSocket(wsUrl);
    } catch (e) {
      console.warn("OverlayRemoteControl: WebSocket init failed:", e);
      return;
    }

    ws.onopen = () => {
      console.log("[OverlayRemoteControl] Connected to", wsUrl);
    };

    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);

        if (data.type === "CITY_ADMIN_OVERLAY_COMMAND") {
          handleCommand(data.command, data.payload);
        }
      } catch (e) {
        console.warn("OverlayRemoteControl: invalid message:", msg.data);
      }
    };

    function handleCommand(cmd, payload) {
      switch (cmd) {
        case "setPreset":
          presetManager.applyPreset(payload);
          break;

        case "setMode":
          controller.setMode(payload);
          break;

        case "toggle":
          controller.setToggles({
            ...controller.toggles,
            [payload]: !controller.toggles[payload]
          });
          break;

        case "setToggles":
          controller.setToggles(payload);
          break;

        case "setHUD":
          controller.setToggles({ ...controller.toggles, hud: payload });
          break;

        case "setNotifications":
          controller.setToggles({ ...controller.toggles, notifications: payload });
          break;

        case "setDebug":
          controller.setToggles({ ...controller.toggles, debug: payload });
          break;

        default:
          console.warn("OverlayRemoteControl: unknown command:", cmd);
      }
    }

    return () => {
      if (ws) ws.close();
    };
  }, [presetManager, controller, wsUrl]);
}

===== END FILE: core\useFestivalOverlayRemoteControl.js =====

===== FILE: core\useFestivalOverlayScenarioAIAutoTuner.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_AUTOTUNER
// Learns from history and auto-adjusts AI profile parameters

import { useEffect, useState, useRef } from "react";
import { FestivalOverlayScenarioAIProfiles } from "./festivalOverlayScenarioAIProfiles";

export function useFestivalOverlayScenarioAIAutoTuner(orchestrator, getCurrentState) {
  const [enabled, setEnabled] = useState(true);
  const history = useRef([]);

  // Track last 50 states
  function pushHistory(state) {
    history.current.push(state);
    if (history.current.length > 50) history.current.shift();
  }

  // Compute metrics
  function computeMetrics() {
    const h = history.current;
    if (h.length < 5) return null;

    const avgPulse = h.reduce((a, s) => a + s.pulse, 0) / h.length;
    const avgWave = h.reduce((a, s) => a + s.wave.intensity, 0) / h.length;
    const moodCounts = h.reduce((acc, s) => {
      acc[s.mood] = (acc[s.mood] || 0) + 1;
      return acc;
    }, {});

    const dominantMood = Object.entries(moodCounts).sort((a, b) => b[1] - a[1])[0][0];

    return { avgPulse, avgWave, dominantMood };
  }

  // Auto-tuning logic
  function tuneProfiles(metrics) {
    const { avgPulse, avgWave, dominantMood } = metrics;

    Object.values(FestivalOverlayScenarioAIProfiles).forEach((profile) => {
      // Adjust speed based on pulse
      if (avgPulse > 120) profile.speed = Math.max(0.5, profile.speed * 0.9);
      else if (avgPulse < 80) profile.speed = Math.min(1.5, profile.speed * 1.1);

      // Adjust intensity based on wave
      if (avgWave > 0.7) profile.intensity = Math.min(1.2, profile.intensity + 0.05);
      else if (avgWave < 0.3) profile.intensity = Math.max(0.2, profile.intensity - 0.05);

      // Mood-based preset bias
      if (dominantMood === "Calm") {
        if (profile.name === "CalmDirector") profile.intensity *= 0.95;
      }
      if (dominantMood === "Energetic") {
        if (profile.name === "AggressiveDirector") profile.intensity *= 1.05;
      }
      if (dominantMood === "Creative") {
        if (profile.name === "ExperimentalDirector") profile.intensity *= 1.1;
      }
    });
  }

  // Main loop
  useEffect(() => {
    if (!enabled) return;

    const interval = setInterval(() => {
      const state = getCurrentState();
      pushHistory(state);

      const metrics = computeMetrics();
      if (metrics) tuneProfiles(metrics);
    }, 2000);

    return () => clearInterval(interval);
  }, [enabled]);

  return {
    enabled,
    setEnabled,
    history
  };
}

===== END FILE: core\useFestivalOverlayScenarioAIAutoTuner.js =====

===== FILE: core\useFestivalOverlayScenarioAIHyperOrchestrator.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERORCHESTRATOR
// The unified super-orchestrator combining Orchestrator + AutoTuner + Profiles + Ultra AI

import { useEffect, useState, useRef } from "react";
import { FestivalOverlayScenarioAIProfiles } from "./festivalOverlayScenarioAIProfiles";
import { generateOverlayScenarioAIWithProfile } from "./festivalOverlayScenarioAI";
import { FestivalOverlayScenarioLibraryUltra } from "./festivalOverlayScenarioLibraryUltra";

export function useFestivalOverlayScenarioAIHyperOrchestrator(runScenarioSteps, getCurrentState) {
  const [enabled, setEnabled] = useState(true);
  const [activeProfile, setActiveProfile] = useState("CalmDirector");
  const [lastRun, setLastRun] = useState(0);

  const history = useRef([]);

  // Push state history (max 100)
  function pushHistory(state) {
    history.current.push(state);
    if (history.current.length > 100) history.current.shift();
  }

  // Compute metrics
  function computeMetrics() {
    const h = history.current;
    if (h.length < 10) return null;

    const avgPulse = h.reduce((a, s) => a + s.pulse, 0) / h.length;
    const avgWave = h.reduce((a, s) => a + s.wave.intensity, 0) / h.length;

    const moodCounts = h.reduce((acc, s) => {
      acc[s.mood] = (acc[s.mood] || 0) + 1;
      return acc;
    }, {});
    const dominantMood = Object.entries(moodCounts).sort((a, b) => b[1] - a[1])[0][0];

    return { avgPulse, avgWave, dominantMood };
  }

  // AutoTuner logic
  function autoTuneProfiles(metrics) {
    const { avgPulse, avgWave, dominantMood } = metrics;

    Object.values(FestivalOverlayScenarioAIProfiles).forEach((profile) => {
      if (avgPulse > 120) profile.speed = Math.max(0.5, profile.speed * 0.9);
      else if (avgPulse < 80) profile.speed = Math.min(1.5, profile.speed * 1.1);

      if (avgWave > 0.7) profile.intensity = Math.min(1.2, profile.intensity + 0.05);
      else if (avgWave < 0.3) profile.intensity = Math.max(0.2, profile.intensity - 0.05);

      if (dominantMood === "Calm" && profile.name === "CalmDirector") profile.intensity *= 0.95;
      if (dominantMood === "Energetic" && profile.name === "AggressiveDirector") profile.intensity *= 1.05;
      if (dominantMood === "Creative" && profile.name === "ExperimentalDirector") profile.intensity *= 1.1;
    });
  }

  // Profile selection logic
  function chooseProfile(state) {
    const { pulse, mood, wave, reputation, security, narrative } = state;

    if (narrative?.phase === "opening") return "FestivalDirector";
    if (narrative?.phase === "awards") return "CinematicDirector";
    if (narrative?.phase === "jury") return "AnalyticalDirector";
    if (pulse > 120 || wave?.intensity > 0.7) return "AggressiveDirector";
    if (mood === "Creative") return "ExperimentalDirector";
    if (security?.trustLevel === "low") return "AnalyticalDirector";

    return "CalmDirector";
  }

  // Ultra scenario fallback
  function maybeRunUltra(state) {
    if (state.wave.intensity > 0.85 || state.pulse > 140) {
      const ultra = FestivalOverlayScenarioLibraryUltra.DynamicPeak(state);
      runScenarioSteps(ultra);
      return true;
    }
    return false;
  }

  // Main loop
  useEffect(() => {
    if (!enabled) return;

    const interval = setInterval(() => {
      const now = Date.now();
      if (now - lastRun < 4000) return;

      const state = getCurrentState();
      pushHistory(state);

      const metrics = computeMetrics();
      if (metrics) autoTuneProfiles(metrics);

      if (maybeRunUltra(state)) {
        setLastRun(now);
        return;
      }

      const profile = chooseProfile(state);
      setActiveProfile(profile);

      const steps = generateOverlayScenarioAIWithProfile(state, profile);
      runScenarioSteps(steps);

      setLastRun(now);
    }, 1000);

    return () => clearInterval(interval);
  }, [enabled, lastRun]);

  return {
    enabled,
    setEnabled,
    activeProfile,
    history
  };
}

===== END FILE: core\useFestivalOverlayScenarioAIHyperOrchestrator.js =====

===== FILE: core\useFestivalOverlayScenarioAIOrchestrator.js =====




// FE_FESTIVAL_OVERLAY_SCENARIO_AI_ORCHESTRATOR
// Autonomous AI director that selects profiles and triggers AI scenarios dynamically

import { useEffect, useState } from "react";
import { FestivalOverlayScenarioAIProfiles } from "./festivalOverlayScenarioAIProfiles";
import { generateOverlayScenarioAIWithProfile } from "./festivalOverlayScenarioAI";

export function useFestivalOverlayScenarioAIOrchestrator(runScenarioSteps, getCurrentState) {
  const [activeProfile, setActiveProfile] = useState("CalmDirector");
  const [autoMode, setAutoMode] = useState(true);
  const [lastRun, setLastRun] = useState(0);

  // Profile selection logic
  function chooseProfile(state) {
    const { pulse, mood, wave, reputation, security, narrative } = state;

    if (narrative?.phase === "opening") return "FestivalDirector";
    if (narrative?.phase === "awards") return "CinematicDirector";
    if (narrative?.phase === "jury") return "AnalyticalDirector";
    if (pulse > 120 || wave?.intensity > 0.7) return "AggressiveDirector";
    if (mood === "Creative") return "ExperimentalDirector";
    if (security?.trustLevel === "low") return "AnalyticalDirector";

    return "CalmDirector";
  }

  // Main orchestrator loop
  useEffect(() => {
    if (!autoMode) return;

    const interval = setInterval(() => {
      const now = Date.now();
      if (now - lastRun < 5000) return; // throttle

      const state = getCurrentState();
      const profile = chooseProfile(state);

      setActiveProfile(profile);

      const steps = generateOverlayScenarioAIWithProfile(state, profile);
      runScenarioSteps(steps);

      setLastRun(now);
    }, 1000);

    return () => clearInterval(interval);
  }, [autoMode, lastRun]);

  return {
    activeProfile,
    autoMode,
    setAutoMode,
    setActiveProfile,
    runOnce: () => {
      runScenarioSteps(steps);
    }
  };
}



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_AUTOTUNER_INTEGRATION
import { useFestivalOverlayScenarioAIAutoTuner } from "./useFestivalOverlayScenarioAIAutoTuner";

// Example usage inside orchestrator:
// const autoTuner = useFestivalOverlayScenarioAIAutoTuner(orchestrator, getCurrentState);

===== END FILE: core\useFestivalOverlayScenarioAIOrchestrator.js =====

===== FILE: core\useFestivalOverlayScenarioComposer.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOCOMPOSER_HOOK
// GUI editor for building overlay scenarios

import { useState } from "react";

export function useFestivalOverlayScenarioComposer() {
  const [scenarios, setScenarios] = useState({});
  const [currentName, setCurrentName] = useState("");
  const [steps, setSteps] = useState([]);

  function addStep(cmd, payload, delay) {
    setSteps((prev) => [...prev, { cmd, payload, delay }]);
  }

  function removeStep(index) {
    setSteps((prev) => prev.filter((_, i) => i !== index));
  }

  function saveScenario(name) {
    setScenarios((prev) => ({
      ...prev,
      [name]: steps
    }));
  }

  function loadScenario(name) {
    setCurrentName(name);
    setSteps(scenarios[name] || []);
  }

  function clear() {
    setSteps([]);
    setCurrentName("");
  }

  return {
    scenarios,
    currentName,
    steps,
    addStep,
    removeStep,
    saveScenario,
    loadScenario,
    clear
  };
}

===== END FILE: core\useFestivalOverlayScenarioComposer.js =====

===== FILE: core\useFestivalOverlayScenarioEngine.js =====




// FE_FESTIVAL_OVERLAY_SCENARIOENGINE_HOOK
// Executes high-level overlay scenarios

import { useState } from "react";
import { FestivalOverlayScenarios } from "./festivalOverlayScenarios";

export function useFestivalOverlayScenarioEngine(presetManager, controller) {
  const [running, setRunning] = useState(false);
  const [currentScenario, setCurrentScenario] = useState(null);

  async function runScenario(name) {
    const scenario = FestivalOverlayScenarios[name];
    if (!scenario) return;

    setRunning(true);
    setCurrentScenario(name);

    for (const step of scenario) {
      await new Promise((res) => setTimeout(res, step.delay));
      execute(step.cmd, step.payload);
    }

    setRunning(false);
    setCurrentScenario(null);
  }

  function execute(cmd, payload) {
    switch (cmd) {
      case "setPreset":
        presetManager.applyPreset(payload);
        break;

      case "setMode":
        controller.setMode(payload);
        break;

      case "toggle":
        controller.setToggles({
          ...controller.toggles,
          [payload]: !controller.toggles[payload]
        });
        break;

      case "setToggles":
        controller.setToggles(payload);
        break;

      default:
        console.warn("ScenarioEngine: unknown command", cmd);
    }
  }

  return {
    running,
    currentScenario,
    runScenario
  };
}



// FE_FESTIVAL_OVERLAY_SCENARIOLIBRARY_INTEGRATION
import { FestivalOverlayScenarioLibrary } from "./festivalOverlayScenarioLibrary";

// Allow ScenarioEngine to run library scenarios
function runLibraryScenario(name) {
  if (!scenario) return;
  runScenarioSteps(scenario);
}

async function runScenarioSteps(steps) {
  setRunning(true);
  setCurrentScenario("Library:" + currentScenario);

  for (const step of steps) {
    await new Promise((res) => setTimeout(res, step.delay));
    execute(step.cmd, step.payload);
  }

  setRunning(false);
  setCurrentScenario(null);
}



// FE_FESTIVAL_OVERLAY_SCENARIOENGINE_AI_EXTENSION
// Minimal AI scenario runner injected automatically

import { buildAIScenarioFromState } from "./festivalOverlayScenarioAI";

async function runAIScenario(currentState) {
  const steps = buildAIScenarioFromState(currentState);
  if (!steps || !steps.length) return;

  setRunning(true);
  setCurrentScenario("AI");

  for (const step of steps) {
    await new Promise((res) => setTimeout(res, step.delay));
    execute(step.cmd, step.payload);
  }

  setRunning(false);
  setCurrentScenario(null);
}

// Example usage inside component:
// runAIScenario({
//   pulse,
//   mood,
//   wave,
//   reputation,
//   identity,
//   security,
//   narrative
// });



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_ORCHESTRATOR_INTEGRATION
import { useFestivalOverlayScenarioAIOrchestrator } from "./useFestivalOverlayScenarioAIOrchestrator";

// Example usage inside ScenarioEngine:
// const orchestrator = useFestivalOverlayScenarioAIOrchestrator(runScenarioSteps, () => ({
//   pulse,
//   mood,
//   wave,
//   reputation,
//   identity,
//   security,
//   narrative
// }));



// FE_FESTIVAL_OVERLAY_SCENARIO_AI_HYPERORCHESTRATOR_INTEGRATION
import { useFestivalOverlayScenarioAIHyperOrchestrator } from "./useFestivalOverlayScenarioAIHyperOrchestrator";

// Example usage inside ScenarioEngine:
// const hyper = useFestivalOverlayScenarioAIHyperOrchestrator(runScenarioSteps, () => ({
//   pulse,
//   mood,
//   wave,
//   reputation,
//   identity,
//   security,
//   narrative
// }));

===== END FILE: core\useFestivalOverlayScenarioEngine.js =====

===== FILE: core\useFestivalPulseMoodLive.js =====




// FE_FESTIVAL_PULSE_MOOD_HOOK
// React hook for live BPM + Mood updates

import { useEffect } from "react";
import { attachFestivalPulseMoodLiveSync } from "../live/festivalPulseMoodLiveSync";

export function useFestivalPulseMoodLive(onPulse, onMood) {
  useEffect(() => {
    attachFestivalPulseMoodLiveSync(onPulse, onMood);
  }, []);
}

===== END FILE: core\useFestivalPulseMoodLive.js =====

===== FILE: core\useFestivalReputationLive.js =====




// FE_FESTIVAL_REPUTATION_HOOK
// React hook for live reputation updates

import { useEffect } from "react";
import { attachFestivalReputationLiveSync } from "../live/festivalReputationLiveSync";

export function useFestivalReputationLive(onReputation) {
  useEffect(() => {
    attachFestivalReputationLiveSync((rep) => {
      onReputation(rep);
    });
  }, []);
}

===== END FILE: core\useFestivalReputationLive.js =====

===== FILE: core\useFestivalSecurityLive.js =====




// FE_FESTIVAL_SECURITY_HOOK
// React hook for live security updates

import { useEffect } from "react";
import { attachFestivalSecurityLiveSync } from "../live/festivalSecurityLiveSync";

export function useFestivalSecurityLive(onSecurity) {
  useEffect(() => {
    attachFestivalSecurityLiveSync((sec) => {
      onSecurity(sec);
    });
  }, []);
}

===== END FILE: core\useFestivalSecurityLive.js =====

===== FILE: core\useFestivalSimulationLive.js =====




// FE_FESTIVAL_SIMULATION_HOOK
// React hook for live simulation/emergence updates

import { useEffect } from "react";
import { attachFestivalSimulationLiveSync } from "../live/festivalSimulationLiveSync";

export function useFestivalSimulationLive(onWave, onPattern) {
  useEffect(() => {
    attachFestivalSimulationLiveSync(onWave, onPattern);
  }, []);
}

===== END FILE: core\useFestivalSimulationLive.js =====

===== FILE: core\useUserCardData.js =====




// FE_FESTIVAL_USERCARD_DATA_HOOK
// Combines identity + governance + security + access into one object

import { useFestivalAccess } from "./useFestivalAccess";

export function useUserCardData(identity, governance, security) {
  const access = useFestivalAccess(identity, governance, security);

  return {
    identity,
    governance,
    security,
    access
  };
}

===== END FILE: core\useUserCardData.js =====

===== FILE: core\director\festivalAIDirectorConflictResolver.js =====




// FE_FESTIVAL_AI_DIRECTOR_CONFLICT_RESOLVER

// Każde źródło (orchestrator, autotuner, scenario, visual) zgłasza propozycję decyzji.
// ConflictResolver wybiera najlepszą na podstawie priorytetów i kontekstu.

export function resolveDirectorConflict({
  orchestratorDecision,
  autoTunerDecision,
  scenarioDecision,
  visualDecision,
  context
}) {
  const candidates = [];

  if (orchestratorDecision) {
    candidates.push({
      source: "orchestrator",
      priority: 5,
      weight: 1.2,
      decision: orchestratorDecision
    });
  }

  if (autoTunerDecision) {
    candidates.push({
      source: "autoTuner",
      priority: 3,
      weight: 1.0,
      decision: autoTunerDecision
    });
  }

  if (scenarioDecision) {
    candidates.push({
      source: "scenario",
      priority: 4,
      weight: 1.1,
      decision: scenarioDecision
    });
  }

  if (visualDecision) {
    candidates.push({
      source: "visual",
      priority: 2,
      weight: 0.9,
      decision: visualDecision
    });
  }

  if (!candidates.length) return null;

  const { pulse, trustLevel, narrativePhase } = context || {};

  return candidates
    .map((c) => {
      let score = c.priority * c.weight;

      if (trustLevel === "low" && c.source === "orchestrator") {
        score -= 1.5;
      }

      if (narrativePhase === "awards" && c.source === "visual") {
        score += 1.0;
      }

      if (pulse > 120 && c.source === "autoTuner") {
        score += 0.5;
      }

      return { ...c, score };
    })
    .sort((a, b) => b.score - a.score)[0].decision;
}

===== END FILE: core\director\festivalAIDirectorConflictResolver.js =====

===== FILE: core\director\festivalAIDirectorMemory.js =====




// FE_FESTIVAL_AI_DIRECTOR_MEMORY

// Prosta pamięć w procesie — w przyszłości możesz ją podmienić na persystencję.
const _directorMemory = {
  history: [],
  maxEntries: 200
};

export function rememberDirectorEvent(event) {
  const entry = {
    timestamp: Date.now(),
    ...event
  };

  _directorMemory.history.push(entry);

  if (_directorMemory.history.length > _directorMemory.maxEntries) {
    _directorMemory.history.shift();
  }
}

export function getDirectorHistory(limit = 50) {
  if (!_directorMemory.history.length) return [];
  return _directorMemory.history.slice(-limit);
}

export function getLastDirectorState() {
  if (!_directorMemory.history.length) return null;
  return _directorMemory.history[_directorMemory.history.length - 1];
}

===== END FILE: core\director\festivalAIDirectorMemory.js =====

===== FILE: core\director\festivalAIDirectorMoodEngine.js =====




// FE_FESTIVAL_AI_DIRECTOR_MOOD_ENGINE

let _currentMood = "Calm";

export const DirectorMoods = {
  Calm: { name: "Calm", tempoMod: 0.9, intensityMod: 0.8 },
  Energetic: { name: "Energetic", tempoMod: 1.3, intensityMod: 1.2 },
  Creative: { name: "Creative", tempoMod: 1.1, intensityMod: 1.0 },
  Tense: { name: "Tense", tempoMod: 1.0, intensityMod: 1.3 },
  Focused: { name: "Focused", tempoMod: 1.0, intensityMod: 0.9 },
  Chaotic: { name: "Chaotic", tempoMod: 1.4, intensityMod: 1.5 }
};

export function getDirectorMood() {
  return _currentMood;
}

export function setDirectorMood(mood) {
  if (DirectorMoods[mood]) {
    _currentMood = mood;
  }
}

export function updateDirectorMood({ pulse, wave, narrativePhase, trustLevel }) {
  if (pulse > 120 || wave > 0.8) {
    _currentMood = "Energetic";
  } else if (trustLevel === "low") {
    _currentMood = "Tense";
  } else if (narrativePhase === "opening" || narrativePhase === "awards") {
    _currentMood = "Creative";
  } else if (pulse < 70 && wave < 0.3) {
    _currentMood = "Calm";
  } else {
    _currentMood = "Focused";
  }

  return _currentMood;
}

===== END FILE: core\director\festivalAIDirectorMoodEngine.js =====

===== FILE: core\director\festivalAIDirectorProfilesUltra.js =====




// FE_FESTIVAL_AI_DIRECTOR_PROFILES_ULTRA

export const FestivalAIDirectorProfilesUltra = {
  CalmDirector: {
    name: "CalmDirector",
    tempo: 0.8,
    intensity: 0.4,
    narrativeStyle: "smooth",
    emotionalBias: "calm",
    scenarioPreferences: ["ambient", "softTransitions", "slowPacing"],
    conflictPriority: 2
  },

  AggressiveDirector: {
    name: "AggressiveDirector",
    tempo: 1.4,
    intensity: 1.2,
    narrativeStyle: "dynamic",
    emotionalBias: "energetic",
    scenarioPreferences: ["fastCuts", "highEnergy", "peakMoments"],
    conflictPriority: 5
  },

  ExperimentalDirector: {
    name: "ExperimentalDirector",
    tempo: 1.1,
    intensity: 1.0,
    narrativeStyle: "creative",
    emotionalBias: "creative",
    scenarioPreferences: ["glitch", "unexpected", "abstract"],
    conflictPriority: 4
  },

  FestivalDirector: {
    name: "FestivalDirector",
    tempo: 1.0,
    intensity: 0.9,
    narrativeStyle: "ceremonial",
    emotionalBias: "focused",
    scenarioPreferences: ["opening", "ceremony", "spotlight"],
    conflictPriority: 5
  },

  CinematicDirector: {
    name: "CinematicDirector",
    tempo: 1.0,
    intensity: 1.1,
    narrativeStyle: "filmic",
    emotionalBias: "dramatic",
    scenarioPreferences: ["wideShots", "slowMotion", "dramaticBeats"],
    conflictPriority: 4
  },

  AnalyticalDirector: {
    name: "AnalyticalDirector",
    tempo: 0.9,
    intensity: 0.7,
    narrativeStyle: "precise",
    emotionalBias: "focused",
    scenarioPreferences: ["structured", "clean", "minimal"],
    conflictPriority: 3
  },

  JuryDirector: {
    name: "JuryDirector",
    tempo: 0.95,
    intensity: 0.8,
    narrativeStyle: "evaluative",
    emotionalBias: "tense",
    scenarioPreferences: ["spotlight", "focus", "analysis"],
    conflictPriority: 4
  },

  AwardsDirector: {
    name: "AwardsDirector",
    tempo: 1.2,
    intensity: 1.0,
    narrativeStyle: "celebratory",
    emotionalBias: "energetic",
    scenarioPreferences: ["spotlight", "goldenGlow", "celebration"],
    conflictPriority: 5
  }
};

===== END FILE: core\director\festivalAIDirectorProfilesUltra.js =====

===== FILE: core\director\festivalAIDirectorSystem.js =====




// FE_FESTIVAL_AI_DIRECTOR_SYSTEM

import { FestivalAIDirectorProfilesUltra } from "./festivalAIDirectorProfilesUltra";
import { getDirectorHistory, rememberDirectorEvent } from "./festivalAIDirectorMemory";
import { getDirectorMood, updateDirectorMood } from "./festivalAIDirectorMoodEngine";
import { resolveDirectorConflict } from "./festivalAIDirectorConflictResolver";

const DirectorMode = {
  FILMIC: "FILMIC",
  SYSTEMIC: "SYSTEMIC",
  HYBRID: "HYBRID"
};

let _currentDirectorProfile = "FestivalDirector";
let _currentDirectorMode = DirectorMode.HYBRID;

export function getCurrentDirectorProfile() {
  return _currentDirectorProfile;
}

export function getCurrentDirectorMode() {
  return _currentDirectorMode;
}

export function setDirectorMode(mode) {
  if (Object.values(DirectorMode).includes(mode)) {
    _currentDirectorMode = mode;
  }
}

export function pickDirectorProfile({ pulse, wave, narrativePhase, trustLevel, reputation }) {
  const mood = updateDirectorMood({ pulse, wave, narrativePhase, trustLevel });

  if (_currentDirectorMode === DirectorMode.FILMIC) {
    if (narrativePhase === "opening") return "FestivalDirector";
    if (narrativePhase === "awards") return "AwardsDirector";
    if (mood === "Creative") return "CinematicDirector";
    return "FestivalDirector";
  }

  if (_currentDirectorMode === DirectorMode.SYSTEMIC) {
    if (trustLevel === "low") return "AnalyticalDirector";
    if (reputation && reputation.level >= 5) return "JuryDirector";
    return "AnalyticalDirector";
  }

  if (trustLevel === "low") {
    _currentDirectorMode = DirectorMode.SYSTEMIC;
    return "AnalyticalDirector";
  }

  if (narrativePhase === "opening" || narrativePhase === "awards") {
    _currentDirectorMode = DirectorMode.FILMIC;
    return "FestivalDirector";
  }

  if (mood === "Creative") {
    return "ExperimentalDirector";
  }

  if (mood === "Energetic") {
    return "AggressiveDirector";
  }

  return "FestivalDirector";
}

export function computeDirectorDecision({
  orchestratorDecision,
  autoTunerDecision,
  scenarioDecision,
  visualDecision,
  context
}) {
  const { pulse, wave, narrativePhase, trustLevel, reputation } = context || {};

  const profileName = pickDirectorProfile({
    pulse,
    wave,
    narrativePhase,
    trustLevel,
    reputation
  });

  _currentDirectorProfile = profileName;

  const finalDecision = resolveDirectorConflict({
    orchestratorDecision,
    autoTunerDecision,
    scenarioDecision,
    visualDecision,
    context: { pulse, trustLevel, narrativePhase }
  });

  rememberDirectorEvent({
    type: "DIRECTOR_DECISION",
    profile: profileName,
    mode: _currentDirectorMode,
    mood: getDirectorMood(),
    pulse,
    wave,
    narrativePhase,
    trustLevel,
    reputation,
    decision: finalDecision
  });

  return {
    profile: profileName,
    mode: _currentDirectorMode,
    mood: getDirectorMood(),
    decision: finalDecision,
    history: getDirectorHistory(20)
  };
}

===== END FILE: core\director\festivalAIDirectorSystem.js =====

===== FILE: core\experience\festivalExperienceModifiers.js =====




// FE_FESTIVAL_EXPERIENCE_MODIFIERS

// Director profile → Pulse/Wave modifiers
export const directorModifiers = {
  CalmDirector:      { pulse: -2,  wave: -0.01 },
  AnalyticalDirector:{ pulse: 0,   wave: 0.00 },
  FestivalDirector:  { pulse: 3,   wave: 0.02 },
  CinematicDirector: { pulse: 6,   wave: 0.04 },
  ExperimentalDirector:{ pulse: 8, wave: 0.05 },
  AggressiveDirector:{ pulse: 12,  wave: 0.06 },
  AwardsDirector:    { pulse: 10,  wave: 0.03 },
  JuryDirector:      { pulse: 0,   wave: 0.00 }
};

// Scenario → Pulse/Wave modifiers
export function scenarioModifiers(scenario) {
  if (!scenario) return { pulse: 0, wave: 0 };

  return {
    pulse: scenario.intensity * 2,
    wave: scenario.intensity * 0.01
  };
}

// VisionMode → Pulse/Wave modifiers
export const visionModifiers = {
  OFF:       { pulse: 0,  wave: 0 },
  HUD:       { pulse: 1,  wave: 0.01 },
  HUD_ULTRA: { pulse: 4,  wave: 0.03 },
  VISION:    { pulse: 8,  wave: 0.05 }
};

// Audience → Pulse/Wave modifiers
export function audienceModifiers(audience) {
  if (!audience) return { pulse: 0, wave: 0 };

  return {
    pulse: audience.energy * 2,
    wave: audience.energy * 0.01
  };
}

// Experience Phase → Pulse/Wave modifiers
export const phaseModifiers = {
  CALM:     { pulse: -5, wave: -0.02 },
  RISING:   { pulse: 2,  wave: 0.01 },
  PEAK:     { pulse: 6,  wave: 0.03 },
  CHAOTIC:  { pulse: 12, wave: 0.05 },
  RECOVERY: { pulse: -2, wave: -0.01 }
};

// Time of day → Pulse/Wave modifiers
export function timeModifiers(hour) {
  if (hour < 10) return { pulse: -3, wave: -0.01 }; // poranek
  if (hour < 18) return { pulse: 0,  wave: 0.00 };  // dzień
  if (hour < 23) return { pulse: 4,  wave: 0.02 };  // wieczór
  return { pulse: 2, wave: 0.01 };                  // noc
}

// Festival type → Pulse/Wave modifiers
export const festivalTypeModifiers = {
  film:     { pulse: 2,  wave: 0.01 },
  music:    { pulse: 8,  wave: 0.05 },
  theatre:  { pulse: 4,  wave: 0.02 },
  gaming:   { pulse: 10, wave: 0.06 },
  expo:     { pulse: 3,  wave: 0.01 }
};

// Combine all modifiers
export function computeExperienceModifiers({
  director,
  scenario,
  visionMode,
  audience,
  phase,
  hour,
  festivalType
}) {
  const d = directorModifiers[director?.profile] || { pulse: 0, wave: 0 };
  const s = scenarioModifiers(scenario);
  const v = visionModifiers[visionMode] || { pulse: 0, wave: 0 };
  const a = audienceModifiers(audience);
  const p = phaseModifiers[phase] || { pulse: 0, wave: 0 };
  const t = timeModifiers(hour);
  const f = festivalTypeModifiers[festivalType] || { pulse: 0, wave: 0 };

  return {
    pulse:
      d.pulse + s.pulse + v.pulse + a.pulse + p.pulse + t.pulse + f.pulse,
    wave:
      d.wave + s.wave + v.wave + a.wave + p.wave + t.wave + f.wave
  };
}

===== END FILE: core\experience\festivalExperienceModifiers.js =====

===== FILE: core\experience\festivalExperienceStateEngine.js =====




// FE_FESTIVAL_EXPERIENCE_STATE_ENGINE

export const ExperiencePhases = {
  CALM: "CALM",
  RISING: "RISING",
  PEAK: "PEAK",
  CHAOTIC: "CHAOTIC",
  RECOVERY: "RECOVERY"
};

// Compute Experience Phase
export function computeExperiencePhase({ pulse, wave, mood, narrativePhase }) {
  if (pulse < 60 && wave < 0.25) return ExperiencePhases.CALM;

  if (pulse < 100 && wave < 0.5) return ExperiencePhases.RISING;

  if (pulse >= 100 && wave >= 0.5 && wave < 0.8) return ExperiencePhases.PEAK;

  if (pulse > 130 || wave >= 0.8 || mood === "Chaotic") {
    return ExperiencePhases.CHAOTIC;
  }

  if (narrativePhase === "closing" || narrativePhase === "awards") {
    return ExperiencePhases.RECOVERY;
  }

  return ExperiencePhases.RISING;
}

// Compute Experience Intensity (0–1)
export function computeExperienceIntensity({ pulse, wave }) {
  const p = Math.min(1, pulse / 150);
  const w = Math.min(1, wave);
  return (p * 0.6) + (w * 0.4);
}

// Compute Experience Signature (unique emotional fingerprint)
export function computeExperienceSignature({ pulse, wave, mood, phase }) {
  return {
    pulse,
    wave,
    mood,
    phase,
    signature: `${phase}::${mood}::${Math.round(pulse)}::${wave.toFixed(2)}`
  };
}

// Main compute function
export function computeExperienceState({ pulse, wave, mood, narrativePhase }) {
  const phase = computeExperiencePhase({ pulse, wave, mood, narrativePhase });
  const intensity = computeExperienceIntensity({ pulse, wave });
  const signature = computeExperienceSignature({ pulse, wave, mood, phase });

  return {
    phase,
    intensity,
    signature
  };
}

===== END FILE: core\experience\festivalExperienceStateEngine.js =====

===== FILE: core\experience\festivalExperienceSyncEngine.js =====




// FE_FESTIVAL_EXPERIENCE_SYNC_ENGINE

import { computePulse } from "./festivalPulseEngine";
import { computeWave } from "./festivalWaveEngine";
import { computeExperienceState } from "./festivalExperienceStateEngine";
import { computeExperienceModifiers } from "./festivalExperienceModifiers";
import { computeDirectorVisionState } from "../festivalAIDirectorVisionOrchestrator";

// Main sync function
export function computeExperienceSync({
  director,
  scenario,
  audience,
  narrativePhase,
  visionMode,
  uiState,
  systemTime,
  festivalType
}) {
  // 1. Pulse
  const pulse = computePulse({
    director,
    scenario,
    visionMode,
    audience
  });

  // 2. Wave
  const wave = computeWave({
    pulse,
    director,
    scenario,
    visionMode,
    audience
  });

  // 3. Experience State
  const experienceState = computeExperienceState({
    pulse,
    wave,
    mood: director?.mood,
    narrativePhase
  });

  // 4. Modifiers
  const modifiers = computeExperienceModifiers({
    director,
    scenario,
    visionMode,
    audience,
    phase: experienceState.phase,
    hour: systemTime?.hour ?? 12,
    festivalType
  });

  // 5. Director Vision State (Warstwa 1)
  const visionState = computeDirectorVisionState({
    orchestratorDecision: null,
    autoTunerDecision: null,
    scenarioDecision: null,
    visualDecision: null,
    context: { pulse, wave, narrativePhase, trustLevel: director?.trustLevel },
    uiState
  });

  return {
    pulse,
    wave,
    experienceState,
    modifiers,
    visionState
  };
}

===== END FILE: core\experience\festivalExperienceSyncEngine.js =====

===== FILE: core\experience\festivalPulseEngine.js =====




// FE_FESTIVAL_PULSE_ENGINE

// Pulse: 0–200
let _pulse = 80;

export function getPulse() {
  return _pulse;
}

// Natural decay
function pulseDecay(pulse) {
  return Math.max(40, pulse - 0.5);
}

// Apply modifiers from director, scenario, vision, audience
function applyPulseModifiers(pulse, modifiers = {}) {
  const {
    directorIntensity = 1.0,
    scenarioImpact = 0.0,
    visionBoost = 0.0,
    audienceEnergy = 0.0
  } = modifiers;

  let result = pulse;

  result += scenarioImpact;
  result += audienceEnergy;
  result *= directorIntensity;
  result += visionBoost;

  return Math.min(200, Math.max(0, result));
}

// Main compute function
export function computePulse({ director, scenario, visionMode, audience }) {
  let pulse = _pulse;

  // 1. Decay
  pulse = pulseDecay(pulse);

  // 2. Director intensity
  const directorIntensity = {
    CalmDirector: 0.95,
    AnalyticalDirector: 1.0,
    FestivalDirector: 1.05,
    CinematicDirector: 1.1,
    ExperimentalDirector: 1.15,
    AggressiveDirector: 1.25,
    AwardsDirector: 1.2,
    JuryDirector: 1.0
  }[director?.profile] || 1.0;

  // 3. Scenario impact
  const scenarioImpact = scenario?.intensity || 0;

  // 4. Vision mode boost
  const visionBoost = {
    OFF: 0,
    HUD: 1,
    HUD_ULTRA: 3,
    VISION: 6
  }[visionMode] || 0;

  // 5. Audience energy
  const audienceEnergy = audience?.energy || 0;

  // 6. Apply modifiers
  pulse = applyPulseModifiers(pulse, {
    directorIntensity,
    scenarioImpact,
    visionBoost,
    audienceEnergy
  });

  _pulse = pulse;
  return _pulse;
}

===== END FILE: core\experience\festivalPulseEngine.js =====

===== FILE: core\experience\festivalWaveEngine.js =====




// FE_FESTIVAL_WAVE_ENGINE

// Wave: 0.0–1.0
let _wave = 0.25;

export function getWave() {
  return _wave;
}

// Natural stabilizer
function waveStabilizer(wave) {
  const target = 0.25;
  const diff = target - wave;
  return wave + diff * 0.02;
}

// Apply modifiers from director, scenario, vision, audience
function applyWaveModifiers(wave, modifiers = {}) {
  const {
    directorFlow = 0.0,
    scenarioFlow = 0.0,
    visionFlow = 0.0,
    audienceFlow = 0.0,
    pulseInfluence = 0.0
  } = modifiers;

  let result = wave;

  result += directorFlow;
  result += scenarioFlow;
  result += visionFlow;
  result += audienceFlow;
  result += pulseInfluence;

  return Math.min(1.0, Math.max(0.0, result));
}

// Main compute function
export function computeWave({ pulse, director, scenario, visionMode, audience }) {
  let wave = _wave;

  // 1. Stabilizer
  wave = waveStabilizer(wave);

  // 2. Director flow
  const directorFlow = {
    CalmDirector: -0.01,
    AnalyticalDirector: 0.0,
    FestivalDirector: 0.02,
    CinematicDirector: 0.04,
    ExperimentalDirector: 0.05,
    AggressiveDirector: 0.06,
    AwardsDirector: 0.03,
    JuryDirector: 0.0
  }[director?.profile] || 0.0;

  // 3. Scenario flow
  const scenarioFlow = (scenario?.intensity || 0) * 0.01;

  // 4. Vision mode flow
  const visionFlow = {
    OFF: 0,
    HUD: 0.01,
    HUD_ULTRA: 0.03,
    VISION: 0.05
  }[visionMode] || 0;

  // 5. Audience flow
  const audienceFlow = (audience?.energy || 0) * 0.01;

  // 6. Pulse influence
  const pulseInfluence = Math.max(0, (pulse - 100) / 300);

  // 7. Apply modifiers
  wave = applyWaveModifiers(wave, {
    directorFlow,
    scenarioFlow,
    visionFlow,
    audienceFlow,
    pulseInfluence
  });

  _wave = wave;
  return _wave;
}

===== END FILE: core\experience\festivalWaveEngine.js =====

===== FILE: core\hyper\festivalHyperDecisionEngine.js =====

// FE_FESTIVAL_HYPER_DECISION_ENGINE

// Podejmowanie decyzji na podstawie zwycięzcy priorytetów
export function computeHyperDecision(inputs, priority) {
  const safeInputs = {
    energy: inputs.energy || {},
    scenario: inputs.scenario || {},
    operator: inputs.operator || {},
    director: inputs.director || {},
    visual: inputs.visual || {}
  };

  const winner = (priority && priority.winner) || "default";

  // Domyślne wartości
  let finalOverlay =
    (safeInputs.visual.overlay && safeInputs.visual.overlay.mode) || "RISING";
  let finalScene =
    safeInputs.scenario.activeScene || null;

  // Mapowanie zwycięzcy na overlay / scenę
  switch (winner) {
    case "operator":
      if (safeInputs.operator.overlay) {
        finalOverlay = safeInputs.operator.overlay;
      } else {
        finalOverlay = "FOCUS";
      }
      break;

    case "director":
      if (safeInputs.director.overlay) {
        finalOverlay = safeInputs.director.overlay;
      } else if (safeInputs.director.intent === "highlight") {
        finalOverlay = "CINEMATIC";
      }
      break;

    case "energy":
      if (safeInputs.energy.overlay) {
        finalOverlay = safeInputs.energy.overlay;
      } else {
        finalOverlay = "CHAOS";
      }
      break;

    case "scene":
      if (safeInputs.scenario.overlay) {
        finalOverlay = safeInputs.scenario.overlay;
      }
      // scena już jest w finalScene
      break;

    case "default":
    default:
      // zostawiamy to, co przyszło z VisualEngine (RISING / inne)
      break;
  }

  return {
    finalScene,
    finalOverlay,
    finalDirectorIntent: (safeInputs.director && safeInputs.director.intent) || null,
    source: winner
  };
}


===== END FILE: core\hyper\festivalHyperDecisionEngine.js =====

===== FILE: core\hyper\festivalHyperInputCollector.js =====

// FE_FESTIVAL_HYPER_INPUT_COLLECTOR — FIXED & SAFE

export function collectHyperInputs(frameInput = {}) {
  return {
    experience: frameInput.experience || { pulse: 0, wave: 0, experienceState: {} },
    scenario: frameInput.scenario || {},
    uiState: frameInput.uiState || {},
    audience: frameInput.audience || { energy: 0 },

    // Najważniejsze — director musi ZAWSZE istnieć
    director: frameInput.director || {
      mood: "Neutral",
      intent: null
    }
  };
}

===== END FILE: core\hyper\festivalHyperInputCollector.js =====

===== FILE: core\hyper\festivalHyperOrchestrator.js =====




// FE_FESTIVAL_HYPER_ORCHESTRATOR

import { computeHyperSync } from "./festivalHyperSyncEngine";

// Główny orchestrator Warstwy 5
export class FestivalHyperOrchestrator {
  constructor() {
    this.state = {
      lastFrame: null,
      frameIndex: 0,
      lastPriority: null,
      lastDecision: null
    };
  }

  computeFrame({ experience, scenario, director, uiState, audience }) {
    const frame = computeHyperSync({
      experience,
      scenario,
      director,
      uiState,
      audience
    });

    this.state.lastFrame = frame;
    this.state.lastPriority = frame.priority;
    this.state.lastDecision = frame.decision;
    this.state.frameIndex++;

    return frame;
  }

  getSnapshot() {
    return {
      frameIndex: this.state.frameIndex,
      lastPriority: this.state.lastPriority,
      lastDecision: this.state.lastDecision,
      lastFrame: this.state.lastFrame
    };
  }
}

===== END FILE: core\hyper\festivalHyperOrchestrator.js =====

===== FILE: core\hyper\festivalHyperPriorityResolver.js =====

// FE_FESTIVAL_HYPER_PRIORITY_RESOLVER

// Priorytety: operator > director > scene > energy > default
export function resolveHyperPriority({ energy, scenario, operator, director }) {
  const layers = {};

  // 1. Operator — absolutny król
  layers.operator = {
    source: "operator",
    weight: 1,
    value: operator,
    score: operator && (operator.overlay || operator.overlayForced) ? 1 : 0,
    reason:
      operator && operator.overlayForced
        ? "overlayForced"
        : operator && operator.overlay
        ? "overlay"
        : null
  };

  // 2. Reżyser — intencja dramaturgiczna
  layers.director = {
    source: "director",
    weight: 1,
    value: director?.intent ?? null,
    score: director?.intent ? 0.8 : 0,
    reason: director?.intent ?? null
  };

  // 3. Scena — aktywna scena
  layers.scene = {
    source: "scene",
    weight: 1,
    value: scenario?.activeScene ?? null,
    score: scenario?.activeScene ? 0.6 : 0,
    reason: scenario?.activeScene ?? null
  };

  // 4. Energia — wysoka energia
  layers.energy = {
    source: "energy",
    weight: 1,
    value: energy?.level ?? null,
    score: energy?.level === "high" ? 0.4 : 0,
    reason: energy?.level === "high" ? "high" : null
  };

  // 5. Default — fallback
  layers.default = {
    source: "default",
    weight: 1,
    value: null,
    score: 0,
    reason: null
  };

  // Wybór zwycięzcy — zgodnie z Twoją logiką
  const winner = pickWinner(layers);

  return {
    winner,
    layers
  };
}

// Funkcja wybierająca zwycięzcę na podstawie score
function pickWinner(layers) {
  let best = "default";
  let bestScore = -Infinity;

  for (const key of Object.keys(layers)) {
    const layer = layers[key];
    const weighted = (layer.score ?? 0) * (layer.weight ?? 1);

    if (weighted > bestScore) {
      bestScore = weighted;
      best = layer.source;
    }
  }

  return best;
}

===== END FILE: core\hyper\festivalHyperPriorityResolver.js =====

===== FILE: core\hyper\festivalHyperSyncEngine.js =====

// FE_FESTIVAL_HYPER_SYNC_ENGINE

import { computeFestivalScenario } from "../festivalScenarioEngine";
import { computeFestivalVisuals } from "../festivalVisualEngine";
import { computeHyperDecision } from "./festivalHyperDecisionEngine";
import { resolveHyperPriority } from "./festivalHyperPriorityResolver";
import { collectHyperInputs } from "./festivalHyperInputCollector";

// Główna funkcja synchronizująca wszystkie warstwy
export function computeHyperSync(rawInputs) {
  // 1. Zbieramy wejścia z różnych źródeł
  const inputs = collectHyperInputs(rawInputs);

  // 2. Liczymy scenariusz (Warstwa 3)
  const scenario = computeFestivalScenario({
    pulse: inputs.pulse,
    wave: inputs.wave,
    mood: inputs.director && inputs.director.mood,
    audience: inputs.audience,
    narrativePhase: inputs.narrativePhase,
    manual: inputs.manualScene
  });

  // 3. Liczymy wizual (Warstwa 4)
  const visual = computeFestivalVisuals({
    pulse: inputs.pulse,
    wave: inputs.wave,
    energy: inputs.energy,
    overlayIntent: inputs.overlayIntent,
    scenario
  });

  // 4. Priorytety (Warstwa 5 — resolver)
  const priority = resolveHyperPriority({
    energy: inputs.energy,
    scenario,
    operator: inputs.operator,
    director: inputs.director
  });

  // 5. Decyzja końcowa (Warstwa 5 — decision)
  const decision = computeHyperDecision(
    {
      energy: inputs.energy,
      scenario,
      operator: inputs.operator,
      director: inputs.director,
      visual
    },
    priority
  );

  return {
    scenario,
    visual,
    priority,
    decision
  };
}


===== END FILE: core\hyper\festivalHyperSyncEngine.js =====

===== FILE: core\scenario\festivalScenarioLibrary.js =====




// FE_FESTIVAL_SCENARIO_LIBRARY

// Hybrydowa biblioteka scen dla FESTIVAL ENGINE 2.0

export const ScenarioLibrary = {
  // --- FILMOWE ---
  cinematic_highlight: {
    type: "film",
    intensity: 0.6,
    tags: ["cinematic", "highlight", "emotional"],
    actions: ["vision_overlay_burst", "director_focus"]
  },

  emotional_peak: {
    type: "film",
    intensity: 0.8,
    tags: ["emotional", "peak"],
    actions: ["hud_ultra_pulse", "director_mood_shift"]
  },

  silent_moment: {
    type: "film",
    intensity: 0.2,
    tags: ["calm", "pause"],
    actions: ["hud_dim", "pulse_decay"]
  },

  // --- MUZYCZNE ---
  music_build_up: {
    type: "music",
    intensity: 0.5,
    tags: ["build", "anticipation"],
    actions: ["wave_rise", "hud_ultra_enable"]
  },

  music_drop: {
    type: "music",
    intensity: 1.0,
    tags: ["drop", "peak", "energy"],
    actions: ["vision_overlay_peak", "pulse_surge", "wave_surge"]
  },

  music_breakdown: {
    type: "music",
    intensity: 0.4,
    tags: ["breakdown", "reset"],
    actions: ["wave_soften", "hud_dim"]
  },

  // --- GAMINGOWE ---
  match_point: {
    type: "gaming",
    intensity: 0.9,
    tags: ["clutch", "peak"],
    actions: ["vision_overlay_focus", "pulse_surge"]
  },

  overtime_surge: {
    type: "gaming",
    intensity: 0.7,
    tags: ["overtime", "tension"],
    actions: ["wave_rise", "director_focus"]
  },

  // --- TEATRALNE / PERFORMATYWNE ---
  dramatic_pause: {
    type: "theatre",
    intensity: 0.3,
    tags: ["pause", "tension"],
    actions: ["hud_dim", "pulse_hold"]
  },

  dramatic_climax: {
    type: "theatre",
    intensity: 0.85,
    tags: ["climax", "peak"],
    actions: ["vision_overlay_burst", "pulse_surge"]
  },

  // --- CROWD FLOW ---
  crowd_rising: {
    type: "crowd",
    intensity: 0.5,
    tags: ["crowd", "rising"],
    actions: ["wave_rise", "hud_ultra_enable"]
  },

  crowd_peak: {
    type: "crowd",
    intensity: 0.9,
    tags: ["crowd", "peak"],
    actions: ["vision_overlay_peak", "pulse_surge"]
  },

  crowd_calm: {
    type: "crowd",
    intensity: 0.2,
    tags: ["crowd", "calm"],
    actions: ["wave_soften", "hud_dim"]
  },

  // --- AI DIRECTOR ---
  director_profile_shift: {
    type: "director",
    intensity: 0.4,
    tags: ["director", "profile"],
    actions: ["director_profile_change", "hud_update"]
  },

  director_mood_shift: {
    type: "director",
    intensity: 0.5,
    tags: ["director", "mood"],
    actions: ["director_mood_change", "hud_ultra_pulse"]
  },

  director_decision_highlight: {
    type: "director",
    intensity: 0.7,
    tags: ["director", "decision"],
    actions: ["vision_overlay_focus", "pulse_surge"]
  },

  // --- SYSTEMOWE / EMOCJONALNE ---
  calm_phase: {
    type: "system",
    intensity: 0.1,
    tags: ["calm"],
    actions: ["pulse_decay", "wave_stabilize"]
  },

  rising_phase: {
    type: "system",
    intensity: 0.4,
    tags: ["rising"],
    actions: ["pulse_rise", "wave_rise"]
  },

  peak_phase: {
    type: "system",
    intensity: 0.9,
    tags: ["peak"],
    actions: ["pulse_surge", "vision_overlay_peak"]
  },

  chaotic_phase: {
    type: "system",
    intensity: 1.0,
    tags: ["chaotic"],
    actions: ["vision_overlay_chaos", "pulse_spike"]
  },

  recovery_phase: {
    type: "system",
    intensity: 0.3,
    tags: ["recovery"],
    actions: ["wave_soften", "pulse_stabilize"]
  }
};

// Narrative sequences (ordered scenes)
export const ScenarioSequences = {
  opening_sequence: [
    "calm_phase",
    "rising_phase",
    "cinematic_highlight"
  ],

  peak_sequence: [
    "music_build_up",
    "music_drop",
    "peak_phase"
  ],

  awards_sequence: [
    "dramatic_pause",
    "director_decision_highlight",
    "dramatic_climax"
  ],

  closing_sequence: [
    "recovery_phase",
    "silent_moment",
    "crowd_calm"
  ]
};

// Narrative arcs (macro-structure)
export const NarrativeArcs = {
  default_arc: [
    "opening_sequence",
    "peak_sequence",
    "awards_sequence",
    "closing_sequence"
  ]
};

===== END FILE: core\scenario\festivalScenarioLibrary.js =====

===== FILE: core\scenario\festivalScenarioOrchestrator.js =====




// FE_FESTIVAL_SCENARIO_ORCHESTRATOR

import { ScenarioLibrary, ScenarioSequences, NarrativeArcs } from "./festivalScenarioLibrary";
import { ScenarioState, setActiveScene, updateSceneDuration } from "./festivalScenarioState";
import { computeScenarioTriggers } from "./festivalScenarioTriggers";
import { resolveScenario } from "./festivalScenarioResolver";

// Akcje scen — placeholdery do integracji z UI, Vision, Audio, itp.
export const ScenarioActions = {
  vision_overlay_burst: () => {},
  vision_overlay_peak: () => {},
  vision_overlay_focus: () => {},
  vision_overlay_chaos: () => {},

  hud_ultra_enable: () => {},
  hud_ultra_pulse: () => {},
  hud_dim: () => {},
  hud_update: () => {},

  pulse_surge: () => {},
  pulse_decay: () => {},
  pulse_rise: () => {},
  pulse_hold: () => {},
  pulse_spike: () => {},
  pulse_stabilize: () => {},

  wave_rise: () => {},
  wave_soften: () => {},
  wave_surge: () => {},
  wave_stabilize: () => {},

  director_focus: () => {},
  director_mood_change: () => {},
  director_profile_change: () => {}
};

// Wykonaj akcje sceny
export function executeSceneActions(sceneName) {
  const scene = ScenarioLibrary[sceneName];
  if (!scene || !scene.actions) return;

  for (const action of scene.actions) {
    const fn = ScenarioActions[action];
    if (fn) fn();
  }
}

// Główna funkcja orchestratora
export function computeScenarioOrchestration({
  pulse,
  wave,
  mood,
  audience,
  narrativePhase,
  manual
}) {
  // 1. Aktualizuj czas trwania sceny
  updateSceneDuration();

  // 2. Oblicz triggery
  const triggers = computeScenarioTriggers({
    pulse,
    wave,
    mood,
    audience,
    narrativePhase,
    manual
  });

  if (!triggers || triggers.length === 0) {
    return {
      scene: ScenarioState.activeScene,
      triggers: [],
      changed: false
    };
  }

  // 3. Resolver wybiera finalną scenę
  const resolvedScene = resolveScenario({
    triggers,
    narrativePhase
  });

  if (!resolvedScene) {
    return {
      scene: ScenarioState.activeScene,
      triggers,
      changed: false
    };
  }

  // 4. Jeśli scena się nie zmieniła → nic nie rób
  if (ScenarioState.activeScene === resolvedScene) {
    return {
      scene: resolvedScene,
      triggers,
      changed: false
    };
  }

  // 5. Ustaw nową scenę
  setActiveScene(resolvedScene);

  // 6. Wykonaj akcje sceny
  executeSceneActions(resolvedScene);

  return {
    scene: resolvedScene,
    triggers,
    changed: true
  };
}

===== END FILE: core\scenario\festivalScenarioOrchestrator.js =====

===== FILE: core\scenario\festivalScenarioResolver.js =====




// FE_FESTIVAL_SCENARIO_RESOLVER

import { ScenarioLibrary, ScenarioSequences } from "./festivalScenarioLibrary";
import { ScenarioState } from "./festivalScenarioState";

// Priorytety scen (im wyżej, tym ważniejsza)
const PRIORITY = {
  director: 100,
  system: 90,
  film: 80,
  music: 70,
  gaming: 60,
  theatre: 50,
  crowd: 40
};

// Wybierz scenę o najwyższym priorytecie
export function resolveScenePriority(sceneNames) {
  if (!sceneNames || sceneNames.length === 0) return null;

  let best = null;
  let bestScore = -Infinity;

  for (const name of sceneNames) {
    const scene = ScenarioLibrary[name];
    if (!scene) continue;

    const score = PRIORITY[scene.type] ?? 0;

    if (score > bestScore) {
      best = name;
      bestScore = score;
    }
  }

  return best;
}

// Rozwiązywanie konfliktów między scenami
export function resolveSceneConflicts(sceneNames) {
  // Jeśli jest tylko jedna scena → nie ma konfliktu
  if (sceneNames.length === 1) return sceneNames[0];

  // Jeśli są sekwencje → sekwencja ma pierwszeństwo
  const sequence = sceneNames.find(name => ScenarioSequences[name]);
  if (sequence) return sequence;

  // Wybierz scenę o najwyższym priorytecie
  return resolveScenePriority(sceneNames);
}

// Wybór sceny z sekwencji

export function resolveSequenceStep(sequenceName) {
  const sequence = ScenarioSequences[sequenceName];
  if (!sequence) return null;

  const index = ScenarioState.history.filter(h => sequence.includes(h.scene)).length;

  return sequence[index] || null;
}


// Główna funkcja resolvera
export function resolveScenario({
  triggers,
  narrativePhase
}) {
  if (!triggers || triggers.length === 0) return null;

  // 1. Rozwiąż konflikty
  const resolved = resolveSceneConflicts(triggers);

  // 2. Jeśli to sekwencja → wybierz krok sekwencji
  if (ScenarioSequences[resolved]) {
    return resolveSequenceStep(resolved);
  }

  // 3. Zwykła scena
  return resolved;
}

===== END FILE: core\scenario\festivalScenarioResolver.js =====

===== FILE: core\scenario\festivalScenarioState.js =====




// FE_FESTIVAL_SCENARIO_STATE

// Stan dramaturgii festiwalu
export const ScenarioState = {
  activeScene: null,
  activeSequence: null,
  narrativePhase: "opening",
  sceneStartTime: null,
  sceneDuration: 0,
  history: [],
  triggers: {
    pulse: false,
    wave: false,
    mood: false,
    audience: false,
    manual: false
  }
};

// Reset state
export function resetScenarioState() {
  ScenarioState.activeScene = null;
  ScenarioState.activeSequence = null;
  ScenarioState.narrativePhase = "opening";
  ScenarioState.sceneStartTime = null;
  ScenarioState.sceneDuration = 0;
  ScenarioState.history = [];
  ScenarioState.triggers = {
    pulse: false,
    wave: false,
    mood: false,
    audience: false,
    manual: false
  };
}

// Ustaw aktywną scenę
export function setActiveScene(sceneName) {
  ScenarioState.activeScene = sceneName;
  ScenarioState.sceneStartTime = Date.now();
  ScenarioState.sceneDuration = 0;
  ScenarioState.history.push({
    scene: sceneName,
    timestamp: Date.now()
  });
}

// Ustaw aktywną sekwencję
export function setActiveSequence(sequenceName) {
  ScenarioState.activeSequence = sequenceName;
}

// Ustaw fazę narracyjną
export function setNarrativePhase(phase) {
  ScenarioState.narrativePhase = phase;
}

// Aktualizuj czas trwania sceny
export function updateSceneDuration() {
  if (ScenarioState.sceneStartTime) {
    ScenarioState.sceneDuration = Date.now() - ScenarioState.sceneStartTime;
  }
}

// Ustaw trigger
export function setTrigger(type, value = true) {
  if (ScenarioState.triggers[type] !== undefined) {
    ScenarioState.triggers[type] = value;
  }
}

// Reset triggerów
export function resetTriggers() {
  for (const key in ScenarioState.triggers) {
    ScenarioState.triggers[key] = false;
  }
}

===== END FILE: core\scenario\festivalScenarioState.js =====

===== FILE: core\scenario\festivalScenarioTriggers.js =====




// FE_FESTIVAL_SCENARIO_TRIGGERS

import { ScenarioLibrary, ScenarioSequences, NarrativeArcs } from "./festivalScenarioLibrary";
import { ScenarioState, setTrigger } from "./festivalScenarioState";

// Pulse-based triggers
export function pulseTriggers(pulse) {
  if (pulse > 130) {
    setTrigger("pulse");
    return "peak_phase";
  }
  if (pulse > 100) {
    setTrigger("pulse");
    return "rising_phase";
  }
  if (pulse < 60) {
    setTrigger("pulse");
    return "calm_phase";
  }
  return null;
}

// Wave-based triggers
export function waveTriggers(wave) {
  if (wave > 0.8) {
    setTrigger("wave");
    return "chaotic_phase";
  }
  if (wave > 0.5) {
    setTrigger("wave");
    return "peak_phase";
  }
  if (wave < 0.25) {
    setTrigger("wave");
    return "calm_phase";
  }
  return null;
}

// Mood-based triggers
export function moodTriggers(mood) {
  if (mood === "Chaotic") {
    setTrigger("mood");
    return "chaotic_phase";
  }
  if (mood === "Creative") {
    setTrigger("mood");
    return "cinematic_highlight";
  }
  if (mood === "Calm") {
    setTrigger("mood");
    return "silent_moment";
  }
  return null;
}

// Audience-based triggers
export function audienceTriggers(audience) {
  if (!audience) return null;

  if (audience.energy > 70) {
    setTrigger("audience");
    return "crowd_peak";
  }
  if (audience.energy > 40) {
    setTrigger("audience");
    return "crowd_rising";
  }
  if (audience.energy < 20) {
    setTrigger("audience");
    return "crowd_calm";
  }
  return null;
}

// Narrative phase triggers
export function narrativePhaseTriggers(phase) {
  switch (phase) {
    case "opening":
      return "opening_sequence";
    case "peak":
      return "peak_sequence";
    case "awards":
      return "awards_sequence";
    case "closing":
      return "closing_sequence";
    default:
      return null;
  }
}

// Manual triggers
export function manualTrigger(sceneName) {
  setTrigger("manual");
  return sceneName;
}

// Combine all triggers
export function computeScenarioTriggers({
  pulse,
  wave,
  mood,
  audience,
  narrativePhase,
  manual
}) {
  const results = [];

  const p = pulseTriggers(pulse);
  if (p) results.push(p);

  const w = waveTriggers(wave);
  if (w) results.push(w);

  const m = moodTriggers(mood);
  if (m) results.push(m);

  const a = audienceTriggers(audience);
  if (a) results.push(a);

  const n = narrativePhaseTriggers(narrativePhase);
  if (n) results.push(n);

  if (manual) {
    const man = manualTrigger(manual);
    if (man) results.push(man);
  }

  return results;
}

===== END FILE: core\scenario\festivalScenarioTriggers.js =====

===== FILE: core\visual\festivalHUDSystem.js =====




// FE_FESTIVAL_HUD_SYSTEM

export const HUDModes = {
  OFF: "OFF",
  HUD: "HUD",
  HUD_ULTRA: "HUD_ULTRA"
};

// Wybór trybu HUD
export function computeHUDMode({ pulse, wave, overlayMode, scene }) {
  // Sceny mają najwyższy priorytet
  if (scene === "music_drop") return HUDModes.HUD_ULTRA;
  if (scene === "dramatic_climax") return HUDModes.HUD_ULTRA;
  if (scene === "match_point") return HUDModes.HUD_ULTRA;

  // Overlay CHAOS → HUD Ultra
  if (overlayMode === "CHAOS") return HUDModes.HUD_ULTRA;

  // Overlay PEAK → HUD Ultra
  if (overlayMode === "PEAK") return HUDModes.HUD_ULTRA;

  // Overlay CINEMATIC → zwykły HUD
  if (overlayMode === "CINEMATIC") return HUDModes.HUD;

  // Pulse/Wave fallback
  if (pulse > 120 || wave > 0.7) return HUDModes.HUD_ULTRA;
  if (pulse < 60 && wave < 0.25) return HUDModes.HUD;

  return HUDModes.HUD;
}

// Efekty HUD
export const HUDEffects = {
  HUD: ({ pulse, wave }) => ({
    opacity: 0.7,
    glow: pulse / 200,
    sweep: wave * 0.3,
    scale: 1.0
  }),

  HUD_ULTRA: ({ pulse, wave }) => ({
    opacity: 1.0,
    glow: 0.5 + pulse / 150,
    sweep: 0.5 + wave * 0.5,
    scale: 1.1 + wave * 0.1,
    pulseEffect: pulse > 100 ? "strong" : "medium"
  }),

  OFF: () => ({
    opacity: 0,
    glow: 0,
    sweep: 0,
    scale: 1.0
  })
};

// Główna funkcja HUD System
export function computeHUDVisuals(params) {
  const mode = computeHUDMode(params);
  const effectFn = HUDEffects[mode] || (() => ({}));
  const effects = effectFn(params);

  return {
    mode,
    effects
  };
}

===== END FILE: core\visual\festivalHUDSystem.js =====

===== FILE: core\visual\festivalVisionOverlayEngine.js =====




// FE_FESTIVAL_VISION_OVERLAY_ENGINE

// Tryby overlayów
export const OverlayModes = {
  OFF: "OFF",
  CALM: "CALM",
  RISING: "RISING",
  PEAK: "PEAK",
  CHAOS: "CHAOS",
  FOCUS: "FOCUS",
  CINEMATIC: "CINEMATIC",
  RECOVERY: "RECOVERY"
};

// Główna funkcja wyboru overlayu
export function computeOverlayMode({
  pulse,
  wave,
  phase,
  scene,
  directorMood
}) {
  // 1. Sceny mają najwyższy priorytet
  if (scene === "music_drop") return OverlayModes.PEAK;
  if (scene === "dramatic_climax") return OverlayModes.CINEMATIC;
  if (scene === "match_point") return OverlayModes.FOCUS;
  if (scene === "chaotic_phase") return OverlayModes.CHAOS;

  // 2. Fazy emocjonalne
  if (phase === "CALM") return OverlayModes.CALM;
  if (phase === "RISING") return OverlayModes.RISING;
  if (phase === "PEAK") return OverlayModes.PEAK;
  if (phase === "CHAOTIC") return OverlayModes.CHAOS;
  if (phase === "RECOVERY") return OverlayModes.RECOVERY;

  // 3. Pulse/Wave fallback
  if (pulse > 130 || wave > 0.8) return OverlayModes.CHAOS;
  if (pulse > 100 || wave > 0.5) return OverlayModes.PEAK;
  if (pulse < 60 && wave < 0.25) return OverlayModes.CALM;

  // 4. Nastrój reżysera
  if (directorMood === "Creative") return OverlayModes.CINEMATIC;
  if (directorMood === "Focused") return OverlayModes.FOCUS;

  return OverlayModes.RISING;
}

// Efekty overlayów
export const OverlayEffects = {
  CALM: () => ({ glow: 0.1, blur: 0.2, color: "blue" }),
  RISING: () => ({ glow: 0.3, sweep: 0.2, color: "teal" }),
  PEAK: () => ({ glow: 0.8, burst: 1.0, color: "neon" }),
  CHAOS: () => ({ distortion: 0.9, glitch: 0.7, color: "red" }),
  FOCUS: () => ({ vignette: 0.6, sharpen: 0.4, color: "white" }),
  CINEMATIC: () => ({ flare: 0.7, grain: 0.3, color: "gold" }),
  RECOVERY: () => ({ fade: 0.4, soften: 0.3, color: "purple" }),
  OFF: () => ({})
};

// Główna funkcja overlay engine
export function computeOverlayVisuals(params) {
  const mode = computeOverlayMode(params);
  const effectFn = OverlayEffects[mode] || (() => ({}));
  const effects = effectFn();

  return {
    mode,
    effects
  };
}

===== END FILE: core\visual\festivalVisionOverlayEngine.js =====

===== FILE: core\visual\festivalVisualEffectsEngine.js =====




// FE_FESTIVAL_VISUAL_EFFECTS_ENGINE

// Efekty bazowe zależne od Pulse
export function computePulseEffects(pulse) {
  return {
    glow: Math.min(1, pulse / 150),
    pulseStrength: pulse > 120 ? "strong" : pulse > 80 ? "medium" : "soft",
    flicker: pulse > 130 ? 0.4 : pulse > 100 ? 0.2 : 0.05
  };
}

// Efekty bazowe zależne od Wave
export function computeWaveEffects(wave) {
  return {
    sweep: wave * 0.8,
    distortion: wave > 0.7 ? 0.6 : wave > 0.5 ? 0.3 : 0.1,
    flow: wave
  };
}

// Efekty zależne od fazy emocjonalnej
export function computePhaseEffects(phase) {
  switch (phase) {
    case "CALM":
      return { fade: 0.4, blur: 0.2, softness: 0.6 };
    case "RISING":
      return { ramp: 0.5, glowBoost: 0.2 };
    case "PEAK":
      return { surge: 1.0, burst: 0.8 };
    case "CHAOTIC":
      return { glitch: 0.7, shake: 0.5 };
    case "RECOVERY":
      return { fade: 0.6, soften: 0.4 };
    default:
      return {};
  }
}

// Efekty zależne od overlay mode
export function computeOverlayEffects(overlayMode) {
  switch (overlayMode) {
    case "PEAK":
      return { neonBoost: 0.8, flare: 0.4 };
    case "CHAOS":
      return { glitch: 0.9, chromatic: 0.6 };
    case "FOCUS":
      return { vignette: 0.5, sharpen: 0.3 };
    case "CINEMATIC":
      return { grain: 0.3, flare: 0.5 };
    default:
      return {};
  }
}

// Efekty zależne od sceny
export function computeSceneEffects(scene) {
  switch (scene) {
    case "music_drop":
      return { surge: 1.0, flash: 0.8 };
    case "dramatic_climax":
      return { flare: 0.7, glowBoost: 0.4 };
    case "match_point":
      return { focusPulse: 0.6, sharpen: 0.4 };
    case "chaotic_phase":
      return { glitch: 0.9, shake: 0.6 };
    default:
      return {};
  }
}

// Efekty zależne od nastroju reżysera
export function computeDirectorEffects(mood) {
  switch (mood) {
    case "Creative":
      return { flare: 0.4, glowBoost: 0.3 };
    case "Focused":
      return { vignette: 0.4, sharpen: 0.3 };
    case "Chaotic":
      return { glitch: 0.6, distortion: 0.4 };
    default:
      return {};
  }
}

// Główna funkcja łączenia efektów
export function computeVisualEffects({
  pulse,
  wave,
  phase,
  overlayMode,
  scene,
  directorMood
}) {
  return {
    ...computePulseEffects(pulse),
    ...computeWaveEffects(wave),
    ...computePhaseEffects(phase),
    ...computeOverlayEffects(overlayMode),
    ...computeSceneEffects(scene),
    ...computeDirectorEffects(directorMood)
  };
}

===== END FILE: core\visual\festivalVisualEffectsEngine.js =====

===== FILE: core\visual\festivalVisualOrchestrator.js =====




// FE_FESTIVAL_VISUAL_ORCHESTRATOR

import { computeVisualSync } from "./festivalVisualSyncEngine";

// Główna funkcja orkiestratora wizualnego
export function computeVisualOrchestration({
  experience,
  scenario,
  director,
  uiState
}) {
  const pulse = experience?.pulse ?? 80;
  const wave = experience?.wave ?? 0.4;
  const phase = experience?.experienceState?.phase ?? "RISING";

  const scene = scenario?.activeScene ?? null;
  const directorMood = director?.mood ?? "Neutral";

  const overlayModeOverride = uiState?.forcedOverlayMode ?? null;

  const visual = computeVisualSync({
    pulse,
    wave,
    phase,
    scene,
    directorMood,
    overlayModeOverride
  });

  return {
    pulse,
    wave,
    phase,
    scene,
    directorMood,
    overlay: visual.overlay,
    hud: visual.hud,
    effects: visual.effects
  };
}

===== END FILE: core\visual\festivalVisualOrchestrator.js =====

===== FILE: core\visual\festivalVisualSyncEngine.js =====




// FE_FESTIVAL_VISUAL_SYNC_ENGINE

import { computeOverlayVisuals } from "./festivalVisionOverlayEngine";
import { computeHUDVisuals } from "./festivalHUDSystem";
import { computeVisualEffects } from "./festivalVisualEffectsEngine";

// Główna funkcja synchronizacji wizualnej
export function computeVisualSync({
  pulse,
  wave,
  phase,
  scene,
  directorMood,
  overlayModeOverride = null
}) {
  // 1. Overlay
  const overlay = computeOverlayVisuals({
    pulse,
    wave,
    phase,
    scene,
    directorMood
  });

  // Możliwość wymuszenia overlayu (np. przez UI)
  const overlayMode = overlayModeOverride || overlay.mode;

  // 2. HUD
  const hud = computeHUDVisuals({
    pulse,
    wave,
    overlayMode,
    scene
  });

  // 3. Efekty wizualne
  const effects = computeVisualEffects({
    pulse,
    wave,
    phase,
    overlayMode,
    scene,
    directorMood
  });

  return {
    overlay: {
      mode: overlayMode,
      effects: overlay.effects
    },
    hud,
    effects
  };
}

===== END FILE: core\visual\festivalVisualSyncEngine.js =====

===== FILE: DATA\useFestivalWorkflowApi.js =====

// Hook API do pracy z workflow FESTIWALU (zgłoszenia, jury, wydarzenia)

import { useEffect, useState } from "react";

const BASE_URL = "/api/festival";

function useWorkflowList(endpoint) {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch(`${BASE_URL}/${endpoint}`)
      .then((res) => res.json())
      .then((data) => {
        setItems(data || []);
        setLoading(false);
      })
      .catch(() => {
        setItems([]);
        setLoading(false);
      });
  }, [endpoint]);

  return { items, loading };
}

export function useFilmSubmissions() {
  return useWorkflowList("filmSubmissions");
}

export function useJuryEvaluations() {
  return useWorkflowList("juryEvaluations");
}

export function useFestivalEvents() {
  return useWorkflowList("events");
}

export async function changeState(entityType, id, newState) {
  const res = await fetch(`${BASE_URL}/${entityType}/${id}/state`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ state: newState })
  });
  return res.json();
}

===== END FILE: DATA\useFestivalWorkflowApi.js =====

===== FILE: FORMS\SubmissionsForm.jsx =====

import React, { useState } from "react";
import { createSubmission } from "../festivalApi.js";

export default function SubmissionsForm() {
  const [title, setTitle] = useState("");
  const [director, setDirector] = useState("");
  const [synopsis, setSynopsis] = useState("");
  const [msg, setMsg] = useState("");

  async function handleSubmit(e) {
    e.preventDefault();
    const res = await createSubmission({ title, director, synopsis });
    setMsg("Zapisano (mock). ID: " + res.id);
  }

  return (
    <div>
      <h2>Nowe zgłoszenie</h2>
      <form onSubmit={handleSubmit}>
        <input value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Tytuł" />
        <input value={director} onChange={(e) => setDirector(e.target.value)} placeholder="Reżyser" />
        <textarea value={synopsis} onChange={(e) => setSynopsis(e.target.value)} placeholder="Opis" />
        <button type="submit">Zapisz</button>
      </form>
      {msg && <p>{msg}</p>}
      <a href="/festival">← Powrót</a>
    </div>
  );
}

===== END FILE: FORMS\SubmissionsForm.jsx =====

===== FILE: JURY\JuryPanel.js =====

export default function JuryPanel() {
  return <div>Jury Panel</div>;
}


// FE_FESTIVAL_LIVE_INTEGRATION
import { useFestivalLive } from "../core/useFestivalLive";

useFestivalLive(() => {
  if (typeof load === "function") load();
});



// FE_FESTIVAL_NARRATIVE_INTEGRATION
import { useFestivalNarrativeLive } from "../core/useFestivalNarrativeLive";

useFestivalNarrativeLive((story) => {
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_PULSE_MOOD_INTEGRATION
import { useFestivalPulseMoodLive } from "../core/useFestivalPulseMoodLive";

useFestivalPulseMoodLive(
  (bpm) => {
    if (typeof setPulse === "function") setPulse(bpm);
  },
  (mood) => {
    if (typeof setMood === "function") setMood(mood);
  }
);



// FE_FESTIVAL_REPUTATION_INTEGRATION
import { useFestivalReputationLive } from "../core/useFestivalReputationLive";

useFestivalReputationLive((rep) => {
  if (typeof setReputation === "function") setReputation(rep);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_GOVERNANCE_INTEGRATION
import { useFestivalGovernanceLive } from "../core/useFestivalGovernanceLive";

useFestivalGovernanceLive((gov) => {
  if (typeof setGovernance === "function") setGovernance(gov);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ECONOMY_INTEGRATION
import { useFestivalEconomyLive } from "../core/useFestivalEconomyLive";

useFestivalEconomyLive((eco) => {
  if (typeof setEconomy === "function") setEconomy(eco);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_SECURITY_INTEGRATION
import { useFestivalSecurityLive } from "../core/useFestivalSecurityLive";

useFestivalSecurityLive((sec) => {
  if (typeof setSecurity === "function") setSecurity(sec);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_IDENTITY_INTEGRATION
import { useFestivalIdentityLive } from "../core/useFestivalIdentityLive";

useFestivalIdentityLive((id) => {
  if (typeof setIdentity === "function") setIdentity(id);
  if (typeof load === "function") load(); // refresh panel
});



// FE_FESTIVAL_ACCESS_INTEGRATION
import { useFestivalAccess } from "../core/useFestivalAccess";

const access = useFestivalAccess(identity, governance, security);

// Example UI guards:
if (!access.canViewDashboard && typeof hidePanel === "function") hidePanel();
if (!access.canVote && typeof disableVoting === "function") disableVoting();
if (!access.canAssignJury && typeof disableAssign === "function") disableAssign();
if (!access.canCreateAwards && typeof disableAwardCreation === "function") disableAwardCreation();
if (!access.canManageEvents && typeof disableEventManagement === "function") disableEventManagement();



// FE_FESTIVAL_USERCARD_INTEGRATION
import { UserCard } from "../components/UserCard";
import { useUserCardData } from "../core/useUserCardData";

const usercard = useUserCardData(identity, governance, security);

// Example usage inside panel render:
// <UserCard {...usercard} />



// FE_FESTIVAL_HUD_INTEGRATION
import { FestivalHUD } from "../components/FestivalHUD";
import { useFestivalHUD } from "../core/useFestivalHUD";

const hud = useFestivalHUD(identity, governance, security);

// Example usage inside render:
// <FestivalHUD {...hud} />



// FE_FESTIVAL_DEBUG_CONSOLE_INTEGRATION
import { FestivalDebugConsole } from "../components/FestivalDebugConsole";
import { useFestivalDebugConsole } from "../core/useFestivalDebugConsole";

const debugConsole = useFestivalDebugConsole();

// Example usage inside render:
// <FestivalDebugConsole
//   logs={debugConsole.logs}
//   collapsed={debugConsole.collapsed}
//   onToggle={debugConsole.toggle}
// />



// FE_FESTIVAL_NOTIFICATIONS_INTEGRATION
import { FestivalNotifications } from "../components/FestivalNotifications";
import { useFestivalNotifications } from "../core/useFestivalNotifications";

const notifications = useFestivalNotifications();

// Example usage inside render:
// <FestivalNotifications notifications={notifications} />



// IMMERSIVE_JURY_PANEL_UPGRADE
// Jury voting, submission details, API integration

import { getJuryAssignmentsForCurrent, getSubmissionDetails, submitJuryVote } from "../api";

export function useImmersiveJuryPanel(setAssignments, setDetails, selected) {
  async function loadAssignments() {
    try {
      const a = await getJuryAssignmentsForCurrent();
      setAssignments(a || []);
    } catch (e) {
      console.warn("ImmersiveJuryPanel loadAssignments error", e);
    }
  }

  async function loadDetails() {
    if (!selected) {
      setDetails(null);
      return;
    }
    try {
      const d = await getSubmissionDetails(selected.submissionId);
      setDetails(d || null);
    } catch (e) {
      console.warn("ImmersiveJuryPanel loadDetails error", e);
    }
  }

  return { loadAssignments, loadDetails };
}

===== END FILE: JURY\JuryPanel.js =====

===== FILE: JURY\JuryReviewList.js =====

export default function JuryReviewList({ reviews }) {
  return (
    <div>
      <h3>Oceny jury</h3>
      <ul>
        {(reviews || []).map((r, i) => (
          <li key={i}>
            {r.submissionId} — {r.score} / {r.comment}
          </li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: JURY\JuryReviewList.js =====

===== FILE: JURY\JuryVoteCard.js =====

export default function JuryVoteCard({ submission }) {
  return (
    <div>
      <h4>Ocena: {submission?.title || submission?.id}</h4>
      {/* TODO: formularz głosowania */}
    </div>
  );
}

===== END FILE: JURY\JuryVoteCard.js =====

===== FILE: live\festivalEconomyLiveSync.js =====




// FE_FESTIVAL_ECONOMY_LIVE_SYNC
// Live sync for Festival Pavilion — tokens, transactions, marketplace synergy

import { onEconomyEvent } from "../core/economyBus";

export function attachFestivalEconomyLiveSync(callback) {
  // callback({ userId, tokens, delta, reason, transaction }) → FE should update UI
  onEconomyEvent((event) => {
    if (event?.payload?.module === "CITY") {
      callback({
        userId: event.payload.userId,
        tokens: event.payload.tokens,
        delta: event.payload.delta,
        reason: event.payload.reason,
        transaction: event.payload.transaction
      });
    }
  });
}

===== END FILE: live\festivalEconomyLiveSync.js =====

===== FILE: live\festivalGovernanceLiveSync.js =====




// FE_FESTIVAL_GOVERNANCE_LIVE_SYNC
// Live sync for Festival Pavilion — roles, certifications, permissions

import { onGovernanceEvent } from "../core/governanceBus";

export function attachFestivalGovernanceLiveSync(callback) {
  // callback({ userId, roles, certifications, permissions }) → FE should update UI
  onGovernanceEvent((event) => {
    if (event?.payload?.module === "CITY") {
      callback({
        userId: event.payload.userId,
        roles: event.payload.roles,
        certifications: event.payload.certifications,
        permissions: event.payload.permissions
      });
    }
  });
}

===== END FILE: live\festivalGovernanceLiveSync.js =====

===== FILE: live\festivalIdentityLiveSync.js =====




// FE_FESTIVAL_IDENTITY_LIVE_SYNC
// Live sync for Festival Pavilion — profile, avatar, badges

import { onIdentityEvent } from "../core/identityBus";

export function attachFestivalIdentityLiveSync(callback) {
  // callback({ userId, profile, avatar, badges }) → FE should update UI
  onIdentityEvent((event) => {
    if (event?.payload?.module === "CITY") {
      callback({
        userId: event.payload.userId,
        profile: event.payload.profile,
        avatar: event.payload.avatar,
        badges: event.payload.badges
      });
    }
  });
}

===== END FILE: live\festivalIdentityLiveSync.js =====

===== FILE: live\festivalLiveSync.js =====




// FE_FESTIVAL_LIVE_SYNC
// Live sync for Festival Pavilion — listens to CityEventBus and updates FE state

import { onCityEvent } from "../core/eventBus";

const FESTIVAL_EVENTS = [
  "FESTIVAL_SUBMISSION_CREATED",
  "FESTIVAL_JURY_ASSIGNED",
  "FESTIVAL_JURY_VOTED",
  "FESTIVAL_AWARD_CATEGORY_CREATED",
  "FESTIVAL_AWARD_GRANTED",
  "FESTIVAL_EVENT_CREATED",
  "FESTIVAL_EVENT_UPDATED",
  "FESTIVAL_SCHEDULE_ENTRY_ADDED"
];

export function attachFestivalLiveSync(callback) {
  // callback(event) → FE should refresh its data
  FESTIVAL_EVENTS.forEach(type => {
    onCityEvent(type, (event) => {
      callback(event);
    });
  });
}

===== END FILE: live\festivalLiveSync.js =====

===== FILE: live\festivalNarrativeLiveSync.js =====




// FE_FESTIVAL_NARRATIVE_LIVE_SYNC
// Live sync for Festival Pavilion narrative feed

import { onNarrativeEvent } from "../core/narrativeBus";

export function attachFestivalNarrativeLiveSync(callback) {
  // callback(story) → FE should update narrative feed
  onNarrativeEvent((event) => {
    if (event?.payload?.module === "FESTIVAL") {
      callback(event.payload.story);
    }
  });
}

===== END FILE: live\festivalNarrativeLiveSync.js =====

===== FILE: live\festivalPulseMoodLiveSync.js =====




// FE_FESTIVAL_PULSE_MOOD_LIVE_SYNC
// Live sync for Festival Pavilion — BPM + Mood updates

import { onPulseEvent, onMoodEvent } from "../core/pulseMoodBus";

export function attachFestivalPulseMoodLiveSync(onPulse, onMood) {
  onPulseEvent((event) => {
    if (event?.payload?.module === "CITY") {
      onPulse(event.payload.bpm);
    }
  });

  onMoodEvent((event) => {
    if (event?.payload?.module === "CITY") {
      onMood(event.payload.mood);
    }
  });
}

===== END FILE: live\festivalPulseMoodLiveSync.js =====

===== FILE: live\festivalReputationLiveSync.js =====




// FE_FESTIVAL_REPUTATION_LIVE_SYNC
// Live sync for Festival Pavilion — reputation, prestige, levels

import { onReputationEvent } from "../core/reputationBus";

export function attachFestivalReputationLiveSync(callback) {
  // callback({ userId, points, level, prestige }) → FE should update UI
  onReputationEvent((event) => {
    if (event?.payload?.module === "CITY") {
      callback({
        userId: event.payload.userId,
        points: event.payload.points,
        level: event.payload.level,
        prestige: event.payload.prestige
      });
    }
  });
}

===== END FILE: live\festivalReputationLiveSync.js =====

===== FILE: live\festivalSecurityLiveSync.js =====




// FE_FESTIVAL_SECURITY_LIVE_SYNC
// Live sync for Festival Pavilion — anti-abuse, throttling, trust-levels

import { onSecurityEvent } from "../core/securityBus";

export function attachFestivalSecurityLiveSync(callback) {
  // callback({ userId, trustLevel, flags, throttling }) → FE should update UI
  onSecurityEvent((event) => {
    if (event?.payload?.module === "CITY") {
      callback({
        userId: event.payload.userId,
        trustLevel: event.payload.trustLevel,
        flags: event.payload.flags,
        throttling: event.payload.throttling
      });
    }
  });
}

===== END FILE: live\festivalSecurityLiveSync.js =====

===== FILE: live\festivalSimulationLiveSync.js =====




// FE_FESTIVAL_SIMULATION_LIVE_SYNC
// Live sync for Festival Pavilion — activity waves + emergent patterns

import { onSimulationEvent, onEmergenceEvent } from "../core/simulationBus";

export function attachFestivalSimulationLiveSync(onWave, onPattern) {
  // Fale aktywności (np. "peak", "low", "surge")
  onSimulationEvent((event) => {
    if (event?.payload?.module === "CITY") {
      onWave({
        intensity: event.payload.intensity,
        trend: event.payload.trend,
        label: event.payload.label
      });
    }
  });

  // Wzorce emergentne (np. "cluster", "burst", "silence")
  onEmergenceEvent((event) => {
    if (event?.payload?.module === "CITY") {
      onPattern({
        type: event.payload.type,
        strength: event.payload.strength,
        description: event.payload.description
      });
    }
  });
}

===== END FILE: live\festivalSimulationLiveSync.js =====

===== FILE: MODULES\FestivalAwards.js =====

export default function FestivalAwards({ awards }) {
  return (
    <div>
      <h3>Nagrody</h3>
      <ul>
        {(awards || []).map((a, i) => (
          <li key={i}>{a.categoryId} → {a.submissionId}</li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: MODULES\FestivalAwards.js =====

===== FILE: MODULES\FestivalSchedule.js =====

export default function FestivalSchedule({ schedule }) {
  return (
    <div>
      <h3>Harmonogram</h3>
      <ul>
        {(schedule || []).map((s, i) => (
          <li key={i}>{s.eventId} — {s.slot}</li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: MODULES\FestivalSchedule.js =====

===== FILE: MODULES\FestivalTimeline.js =====

export default function FestivalTimeline({ events }) {
  return (
    <div>
      <h3>Oś czasu festiwalu</h3>
      <ul>
        {(events || []).map(e => (
          <li key={e.id}>{e.name} — {new Date(e.startsAt).toLocaleString()}</li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: MODULES\FestivalTimeline.js =====

===== FILE: PANELS\EventWorkflowPanel.js =====

import React from "react";
import { useFestivalEvents, changeState } from "../DATA/useFestivalWorkflowApi";

const NEXT_STATES = {
  planned: ["published"],
  published: ["archived"],
  archived: []
};

export function EventWorkflowPanel() {
  const { items, loading } = useFestivalEvents();

  if (loading) return <div>Ładowanie wydarzeń...</div>;
  if (!items.length) return <div>Brak wydarzeń festiwalowych.</div>;

  const handleChange = (id, state) => async () => {
    await changeState("events", id, state);
    window.location.reload();
  };

  return (
    <div>
      <h2>Workflow wydarzeń festiwalowych</h2>
      <ul>
        {items.map((item) => {
          const nextStates = NEXT_STATES[item.state] || [];
          return (
            <li key={item.id} style={{ marginBottom: "8px" }}>
              <strong>{item.name}</strong> — stan: {item.state}
              <div>
                {nextStates.map((s) => (
                  <button
                    key={s}
                    onClick={handleChange(item.id, s)}
                    style={{ marginRight: "4px" }}
                  >
                    {s}
                  </button>
                ))}
              </div>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

===== END FILE: PANELS\EventWorkflowPanel.js =====

===== FILE: PANELS\FilmSubmissionsWorkflowPanel.js =====

import React from "react";
import { useFilmSubmissions, changeState } from "../DATA/useFestivalWorkflowApi";

const NEXT_STATES = {
  draft: ["submitted"],
  submitted: ["under_review"],
  under_review: ["accepted", "rejected"],
  accepted: ["awarded"],
  rejected: [],
  awarded: []
};

export function FilmSubmissionsWorkflowPanel() {
  const { items, loading } = useFilmSubmissions();

  if (loading) return <div>Ładowanie zgłoszeń...</div>;
  if (!items.length) return <div>Brak zgłoszeń filmowych.</div>;

  const handleChange = (id, state) => async () => {
    await changeState("filmSubmissions", id, state);
    window.location.reload(); // proste odświeżenie, do wymiany na lepsze
  };

  return (
    <div>
      <h2>Workflow zgłoszeń filmowych</h2>
      <ul>
        {items.map((item) => {
          const nextStates = NEXT_STATES[item.state] || [];
          return (
            <li key={item.id} style={{ marginBottom: "8px" }}>
              <strong>{item.title}</strong> — stan: {item.state}
              <div>
                {nextStates.map((s) => (
                  <button
                    key={s}
                    onClick={handleChange(item.id, s)}
                    style={{ marginRight: "4px" }}
                  >
                    {s}
                  </button>
                ))}
              </div>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

===== END FILE: PANELS\FilmSubmissionsWorkflowPanel.js =====

===== FILE: PANELS\JuryWorkflowPanel.js =====

import React from "react";
import { useJuryEvaluations, changeState } from "../DATA/useFestivalWorkflowApi";

const NEXT_STATES = {
  assigned: ["evaluating"],
  evaluating: ["completed"],
  completed: []
};

export function JuryWorkflowPanel() {
  const { items, loading } = useJuryEvaluations();

  if (loading) return <div>Ładowanie prac jury...</div>;
  if (!items.length) return <div>Brak prac jury.</div>;

  const handleChange = (id, state) => async () => {
    await changeState("juryEvaluations", id, state);
    window.location.reload();
  };

  return (
    <div>
      <h2>Workflow jury</h2>
      <ul>
        {items.map((item) => {
          const nextStates = NEXT_STATES[item.state] || [];
          return (
            <li key={item.id} style={{ marginBottom: "8px" }}>
              <strong>{item.filmTitle}</strong> — stan: {item.state}
              <div>
                {nextStates.map((s) => (
                  <button
                    key={s}
                    onClick={handleChange(item.id, s)}
                    style={{ marginRight: "4px" }}
                  >
                    {s}
                  </button>
                ))}
              </div>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

===== END FILE: PANELS\JuryWorkflowPanel.js =====

===== FILE: PANELS\SubmissionDetails.jsx =====

import React, { useEffect, useState } from "react";
import { getSubmissionById } from "../festivalApi.js";

export default function SubmissionDetails({ submissionId }) {
  const [submission, setSubmission] = useState(null);

  useEffect(() => {
    (async () => {
      const data = await getSubmissionById(submissionId);
      setSubmission(data);
    })();
  }, [submissionId]);

  if (!submission) return <div>Ładowanie...</div>;

  return (
    <div>
      <h2>Szczegóły zgłoszenia</h2>
      <p>{submission.title}</p>
      <p>{submission.director}</p>
      <p>{submission.synopsis}</p>
      <a href="/festival">← Powrót</a>
    </div>
  );
}

===== END FILE: PANELS\SubmissionDetails.jsx =====

===== FILE: PANELS\SubmissionsList.jsx =====

import React, { useEffect, useState } from "react";
import { getSubmissions } from "../festivalApi.js";

export default function SubmissionsList() {
  const [submissions, setSubmissions] = useState([]);

  useEffect(() => {
    (async () => {
      const data = await getSubmissions();
      setSubmissions(data);
    })();
  }, []);

  return (
    <div>
      <h2>Zgłoszenia festiwalowe</h2>
      <ul>
        {submissions.map((s) => (
          <li key={s.id}>
            {s.title} — {s.director} ({s.status}){" "}
            <a href={"/festival/submission/" + s.id}>Szczegóły</a>
          </li>
        ))}
      </ul>
      <a href="/festival/submit">Dodaj nowe zgłoszenie</a>
    </div>
  );
}

===== END FILE: PANELS\SubmissionsList.jsx =====

===== FILE: RELATIONS\CreatorFestivalRelations.js =====

export default function CreatorFestivalRelations({ relations }) {
  return (
    <div>
      <h3>Relacje twórca ↔ festiwal</h3>
      <ul>
        {(relations || []).map((r, i) => (
          <li key={i}>{r.creatorId} → {r.submissionId}</li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: RELATIONS\CreatorFestivalRelations.js =====

===== FILE: RELATIONS\SubmissionRelations.js =====

export default function SubmissionRelations({ relations }) {
  return (
    <div>
      <h3>Relacje zgłoszenie ↔ jury / nagrody</h3>
      <ul>
        {(relations || []).map((r, i) => (
          <li key={i}>{r.submissionId} → {r.targetId} ({r.type})</li>
        ))}
      </ul>
    </div>
  );
}

===== END FILE: RELATIONS\SubmissionRelations.js =====

===== FILE: WORKFLOW\AwardsWorkflow.js =====

export default function AwardsWorkflow() {
  return <div>Awards Workflow (UI)</div>;
}

===== END FILE: WORKFLOW\AwardsWorkflow.js =====

===== FILE: WORKFLOW\JuryWorkflow.js =====

export default function JuryWorkflow() {
  return <div>Jury Workflow (UI)</div>;
}

===== END FILE: WORKFLOW\JuryWorkflow.js =====

===== FILE: WORKFLOW\SubmissionWorkflow.js =====

export default function SubmissionWorkflow() {
  return <div>Submission Workflow (UI)</div>;
}

===== END FILE: WORKFLOW\SubmissionWorkflow.js =====

